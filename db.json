{"meta":{"version":1,"warehouse":"4.0.2"},"models":{"Asset":[{"_id":"source/CNAME","path":"CNAME","modified":0,"renderable":0},{"_id":"themes/next/source/css/main.styl","path":"css/main.styl","modified":0,"renderable":1},{"_id":"themes/next/source/css/noscript.styl","path":"css/noscript.styl","modified":0,"renderable":1},{"_id":"themes/next/source/images/apple-touch-icon-next.png","path":"images/apple-touch-icon-next.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/avatar.gif","path":"images/avatar.gif","modified":0,"renderable":1},{"_id":"themes/next/source/images/favicon-16x16-next.png","path":"images/favicon-16x16-next.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/favicon-32x32-next.png","path":"images/favicon-32x32-next.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/logo-algolia-nebula-blue-full.svg","path":"images/logo-algolia-nebula-blue-full.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/logo.svg","path":"images/logo.svg","modified":0,"renderable":1},{"_id":"themes/next/source/js/bookmark.js","path":"js/bookmark.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/comments.js","path":"js/comments.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/config.js","path":"js/config.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/motion.js","path":"js/motion.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/comments-buttons.js","path":"js/comments-buttons.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/next-boot.js","path":"js/next-boot.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/pjax.js","path":"js/pjax.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/schedule.js","path":"js/schedule.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/utils.js","path":"js/utils.js","modified":0,"renderable":1},{"_id":"themes/next/source/images/custom/about.txt","path":"images/custom/about.txt","modified":0,"renderable":1},{"_id":"themes/next/source/images/custom/android-chrome-192x192.png","path":"images/custom/android-chrome-192x192.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/custom/android-chrome-512x512.png","path":"images/custom/android-chrome-512x512.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/custom/apple-touch-icon.png","path":"images/custom/apple-touch-icon.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/custom/favicon-16x16.png","path":"images/custom/favicon-16x16.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/custom/favicon-32x32.png","path":"images/custom/favicon-32x32.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/custom/favicon.ico","path":"images/custom/favicon.ico","modified":0,"renderable":1},{"_id":"themes/next/source/images/custom/ranfang.jpg","path":"images/custom/ranfang.jpg","modified":0,"renderable":1},{"_id":"themes/next/source/images/custom/site.webmanifest","path":"images/custom/site.webmanifest","modified":0,"renderable":1},{"_id":"themes/next/source/js/third-party/fancybox.js","path":"js/third-party/fancybox.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/third-party/pace.js","path":"js/third-party/pace.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/third-party/quicklink.js","path":"js/third-party/quicklink.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/third-party/rating.js","path":"js/third-party/rating.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/schemes/muse.js","path":"js/schemes/muse.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/third-party/analytics/baidu-analytics.js","path":"js/third-party/analytics/baidu-analytics.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/third-party/analytics/google-analytics.js","path":"js/third-party/analytics/google-analytics.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/third-party/analytics/growingio.js","path":"js/third-party/analytics/growingio.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/third-party/analytics/matomo.js","path":"js/third-party/analytics/matomo.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/third-party/chat/chatra.js","path":"js/third-party/chat/chatra.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/third-party/chat/gitter.js","path":"js/third-party/chat/gitter.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/third-party/chat/tidio.js","path":"js/third-party/chat/tidio.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/third-party/comments/changyan.js","path":"js/third-party/comments/changyan.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/third-party/comments/disqus.js","path":"js/third-party/comments/disqus.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/third-party/comments/disqusjs.js","path":"js/third-party/comments/disqusjs.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/third-party/comments/gitalk.js","path":"js/third-party/comments/gitalk.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/third-party/comments/isso.js","path":"js/third-party/comments/isso.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/third-party/comments/livere.js","path":"js/third-party/comments/livere.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/third-party/comments/utterances.js","path":"js/third-party/comments/utterances.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/third-party/math/katex.js","path":"js/third-party/math/katex.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/third-party/math/mathjax.js","path":"js/third-party/math/mathjax.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/third-party/search/algolia-search.js","path":"js/third-party/search/algolia-search.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/third-party/search/local-search.js","path":"js/third-party/search/local-search.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/third-party/statistics/firestore.js","path":"js/third-party/statistics/firestore.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/third-party/statistics/lean-analytics.js","path":"js/third-party/statistics/lean-analytics.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/third-party/tags/mermaid.js","path":"js/third-party/tags/mermaid.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/third-party/tags/pdf.js","path":"js/third-party/tags/pdf.js","modified":0,"renderable":1}],"Cache":[{"_id":"source/CNAME","hash":"e348bc0cd8452a13fcce50ed3d73f17456635949","modified":1664557491461},{"_id":"source/_posts/Cpp-Learning-Notes-Template.md","hash":"2ff727ecbb7b34be57a06970e417ddfd938481ea","modified":1664557491461},{"_id":"source/_posts/Makefile-Learning-Notes.md","hash":"8daf001cf2b6ed47613ff25e04897412145aca48","modified":1664557491461},{"_id":"source/_posts/hello-world.md","hash":"0c981fbae31bdeeb2563577d10075213dc25d250","modified":1664557491461},{"_id":"source/about/index.md","hash":"887cbf16227e54a20a5dbbf2545451265408fdfa","modified":1664557491461},{"_id":"source/cv/index.md","hash":"0df5348abf78f0accb5bdd47c5f75a5009f15a6a","modified":1664557491461},{"_id":"source/tags/index.md","hash":"bcdb3c86cbba474644864f3f6160db3ec7873c20","modified":1664557491461},{"_id":"themes/next/LICENSE.md","hash":"68fc9a03d50fd4b5ea97092b05967d1819dea2c4","modified":1664557711722},{"_id":"themes/next/_vendors.yml","hash":"6a7bab46b4fc9d7722e29e2dac549def0d8dcaa3","modified":1664557711806},{"_id":"themes/next/package.json","hash":"bbe3995c35b05028273e1def2394c3333a270654","modified":1664557711698},{"_id":"themes/next/README.md","hash":"56638e4978154a2f2a3f03ba84047b77b4a499cc","modified":1664557711722},{"_id":"themes/next/_config.yml","hash":"89519df08bf91ee5ad72f51524fd7906b18d005e","modified":1664554010740},{"_id":"themes/next/docs/AUTHORS.md","hash":"a648823121563c34a177ae91f5a774b5e29f01a0","modified":1664557711718},{"_id":"themes/next/_config.yml.backup","hash":"a4829c703f4ad1fc4ae16b28ffabded43af7aba1","modified":1664557711806},{"_id":"themes/next/docs/LICENSE.txt","hash":"f5b14f791b7cfa1d16da981d929152e088a5d1b8","modified":1664557711806},{"_id":"themes/next/languages/README.md","hash":"b2567e32805dda79601157351a07e5ca9fe01315","modified":1664557711722},{"_id":"themes/next/languages/ar.yml","hash":"bca66db21c015dbd32970d8708b898518a773e1e","modified":1664557711806},{"_id":"themes/next/languages/bn.yml","hash":"fccbf2855392186e11daa8590121073594037b7b","modified":1664557711806},{"_id":"themes/next/languages/de.yml","hash":"4be7b8b76c81bf1853eb36d2e874b17546a0e792","modified":1664557711810},{"_id":"themes/next/languages/en.yml","hash":"814d81c27fed736055ee300e0a6505b26ff4313c","modified":1664557711810},{"_id":"themes/next/languages/es.yml","hash":"b813da5aed9d73b809133db4dfb08f90ec56afd9","modified":1664557711810},{"_id":"themes/next/languages/fa.yml","hash":"6456d40dd42f44101d9d6e7054e9884e9163f948","modified":1664557711810},{"_id":"themes/next/languages/fr.yml","hash":"b15dc05afdc94de02e5d3fee4f8d3dc5594dd37e","modified":1664557711810},{"_id":"themes/next/docs/AGPL3.md","hash":"0d2b8c5fa8a614723be0767cc3bca39c49578036","modified":1664557711714},{"_id":"themes/next/languages/id.yml","hash":"14e794db4eca36b257994d81eb513e61d1edcbd6","modified":1664557711810},{"_id":"themes/next/languages/it.yml","hash":"c1eeab4992c76bfd436bb205ce58b1cfeef55ee6","modified":1664557711810},{"_id":"themes/next/languages/ja.yml","hash":"d48c4157e0e02e847aac7b513580d3364c81948c","modified":1664557711814},{"_id":"themes/next/languages/ko.yml","hash":"819c19eb9d142e5411f77cf3821d90f740ee114a","modified":1664557711814},{"_id":"themes/next/languages/pt-BR.yml","hash":"a1f27b3a592fc58f17d247f5563ff4a90a3da5f2","modified":1664557711814},{"_id":"themes/next/languages/nl.yml","hash":"ecb8e39c6225f3c068a5fdd569ee7dafd5c41a1f","modified":1664557711814},{"_id":"themes/next/languages/pt.yml","hash":"63a3e1e728ba5e6e22150de7331bb8a654f34960","modified":1664557711814},{"_id":"themes/next/languages/si.yml","hash":"615d18d044f44df476d6bfbf73f7b0edc2632168","modified":1664557711814},{"_id":"themes/next/languages/tr.yml","hash":"0bebba73d6f06c7dad61f80c0d7ad5f6f1791a01","modified":1664557711814},{"_id":"themes/next/languages/tk.yml","hash":"519239e35c3bda7b62b00ff5d34644f45b16fe6a","modified":1664557711814},{"_id":"themes/next/languages/ru.yml","hash":"8c2b6361f2de17561c1a3eede2bf47b4e2ba6ce5","modified":1664557711814},{"_id":"themes/next/languages/vi.yml","hash":"c669c34da544a563ceae3e196addc9df6a78e024","modified":1664557711814},{"_id":"themes/next/languages/uk.yml","hash":"7dd24580c0865c5a7bc4d391855045366a598936","modified":1664557711814},{"_id":"themes/next/languages/zh-CN.yml","hash":"5a3ab21210304efef736e96bad254f789f42c567","modified":1664557711814},{"_id":"themes/next/languages/zh-HK.yml","hash":"f195bb0502ffe66e850077a1af1033455ea65f93","modified":1664557711814},{"_id":"themes/next/languages/zh-TW.yml","hash":"92256b90028de9a1e79c6bc0e5885b93e7fb4b17","modified":1664557711814},{"_id":"themes/next/layout/_layout.njk","hash":"20e4160cd0deb4fa272cc3aed0f43520b3cf4a9c","modified":1664557711722},{"_id":"themes/next/layout/archive.njk","hash":"d759f4d2cf5ddc6875ea250113a00662c1caf6d1","modified":1664557711722},{"_id":"themes/next/layout/category.njk","hash":"c68b7343d0f8145010f93351908cc36ef6212ec1","modified":1664557711730},{"_id":"themes/next/layout/index.njk","hash":"dd63e488ae8cc144335a5958acedf6a16edd7a92","modified":1664557711738},{"_id":"themes/next/layout/page.njk","hash":"6c40aa438c658eb7f0cd0f6a759f18b43e7e8f93","modified":1664557711746},{"_id":"themes/next/layout/tag.njk","hash":"9e16ba20c28a7f2c6bc75aa427f48122301a30aa","modified":1664557711754},{"_id":"themes/next/layout/post.njk","hash":"6abeb85fb3e4c382ed4bb6049b12a807e6226e67","modified":1664557711750},{"_id":"themes/next/docs/ru/README.md","hash":"6c82bfd2ec8248c248da701f091b548a7a133580","modified":1664557711722},{"_id":"themes/next/docs/zh-CN/CODE_OF_CONDUCT.md","hash":"7a06d443f374bd1e84294067a0ac796afd9fbe60","modified":1664557711718},{"_id":"themes/next/docs/zh-CN/README.md","hash":"ccf27b9249524b9fec1c15497b4353c8d1748c6c","modified":1664557711722},{"_id":"themes/next/layout/_macro/post-collapse.njk","hash":"1a30d751871dabfa80940042ddb1f77d07d830b9","modified":1664557711750},{"_id":"themes/next/layout/_partials/footer.njk","hash":"19713f472972caac33ae5fbcfe9105da61257de4","modified":1664557711738},{"_id":"themes/next/layout/_partials/languages.njk","hash":"e43f22198cccb5f6e306b1ce0d28d12a4fb891f8","modified":1664557711738},{"_id":"themes/next/layout/_partials/pagination.njk","hash":"9876dbfc15713c7a47d4bcaa301f4757bd978269","modified":1664557711746},{"_id":"themes/next/layout/_partials/widgets.njk","hash":"852a750524decf1efa587cd52b09e387ed8315de","modified":1664557711754},{"_id":"themes/next/docs/zh-CN/CONTRIBUTING.md","hash":"a089f7a8368ab0b7d7b9b7ec0ac3767a453435df","modified":1664557711718},{"_id":"themes/next/layout/_scripts/index.njk","hash":"6668878a0f9a1166c6a879755f54a08d942da870","modified":1664557711738},{"_id":"themes/next/layout/_scripts/vendors.njk","hash":"be80b9fe415a9a09d74c28e230995fd292dfc123","modified":1664557711754},{"_id":"themes/next/layout/_partials/comments.njk","hash":"d0c470b0f6690aa217e9ada848c5e2e73fb27c6f","modified":1664557711734},{"_id":"themes/next/layout/_third-party/index.njk","hash":"d41eeb262978e34de4679d8971a9e7ac5d90ecbc","modified":1664557711738},{"_id":"themes/next/layout/_third-party/fancybox.njk","hash":"844559f46e2ff1c8be234d5763703106e2072a7b","modified":1664557711734},{"_id":"themes/next/layout/_third-party/pace.njk","hash":"d7ad5714079f7f65446f880baf14722435ca9061","modified":1664557711746},{"_id":"themes/next/layout/_third-party/quicklink.njk","hash":"0efed71ed530447718c4ea5bbd5fc8695b0b0d5f","modified":1664557711750},{"_id":"themes/next/source/css/_colors.styl","hash":"3c6798c10cc220d83481cb3f3782e78558cee789","modified":1664557711766},{"_id":"themes/next/layout/_third-party/rating.njk","hash":"1bcdbc7fde26d6d9ef4e7fa43ffcff5a9506b20e","modified":1664557711750},{"_id":"themes/next/source/css/main.styl","hash":"78ce791cc4ac95386cf6839ca72f5f7b51f86ee9","modified":1664557711790},{"_id":"themes/next/source/css/_mixins.styl","hash":"32d31cb5a155681c19f5ad0bb56dcb08429f93ef","modified":1664557711774},{"_id":"themes/next/source/css/noscript.styl","hash":"263eddabfae40e54c0591e7baa8403ade8cdd56d","modified":1664557711794},{"_id":"themes/next/source/images/apple-touch-icon-next.png","hash":"2959dbc97f31c80283e67104fe0854e2369e40aa","modified":1664557711758},{"_id":"themes/next/source/images/avatar.gif","hash":"2dbc3e2f2d624b2ca1afe6edc2ca17307f1950c8","modified":1664557711654},{"_id":"themes/next/source/images/favicon-32x32-next.png","hash":"0749d7b24b0d2fae1c8eb7f671ad4646ee1894b1","modified":1664557711758},{"_id":"themes/next/source/images/favicon-16x16-next.png","hash":"943a0d67a9cdf8c198109b28f9dbd42f761d11c3","modified":1664557711758},{"_id":"themes/next/source/js/bookmark.js","hash":"0f563ffbf05fad30e854e413ab17ff7164ab5a53","modified":1664557711658},{"_id":"themes/next/source/images/logo.svg","hash":"2cb74fd3ea2635e015eabc58a8d488aed6cf6417","modified":1664557711806},{"_id":"themes/next/source/images/logo-algolia-nebula-blue-full.svg","hash":"b85e274207b1392782476a0430feac98db1e7da0","modified":1664557711806},{"_id":"themes/next/source/js/comments.js","hash":"66ae2e26ea36a41b72c638ea8b220296638ae952","modified":1664557711666},{"_id":"themes/next/source/js/config.js","hash":"4c4ebbe3b3f3841a26f9d5af6d0ba8bc6da01c54","modified":1664557711666},{"_id":"themes/next/source/js/comments-buttons.js","hash":"1a7344440321713426a0b2ab17e276b5bdf85ade","modified":1664557711666},{"_id":"themes/next/source/js/next-boot.js","hash":"da0f07f9eaaa83de70128b0feaea3fdadb90457a","modified":1664557711686},{"_id":"themes/next/source/js/motion.js","hash":"f7c825cbff11885fa0dffa64824fd00e505d6a8d","modified":1664557711686},{"_id":"themes/next/source/js/pjax.js","hash":"919f5281c4a04d11cfd94573ecf57b3dbabd3cc8","modified":1664557711690},{"_id":"themes/next/source/js/schedule.js","hash":"a1333258726caf84f368a8f8454639c7dc1626bb","modified":1664557711694},{"_id":"themes/next/scripts/events/index.js","hash":"3ce10d4cce94e3d4c482c2e18bb6f0f0ca380d3d","modified":1664557711678},{"_id":"themes/next/scripts/filters/locals.js","hash":"9eb5310664759931287dd28ea39165dfb67f12ed","modified":1664557711682},{"_id":"themes/next/layout/_macro/sidebar.njk","hash":"eb786e8b35e354287cda345c524cd35ec955f692","modified":1664557711750},{"_id":"themes/next/scripts/filters/default-injects.js","hash":"872f01cb10e422a648ea505436532e776e92926b","modified":1664557711670},{"_id":"themes/next/scripts/filters/post.js","hash":"30e03a1d4828259f82d46e64cbfe2955b6cff9a9","modified":1664557711690},{"_id":"themes/next/source/js/utils.js","hash":"200088bfd042f5304b2a04befab0829148845e0e","modified":1664557711694},{"_id":"themes/next/layout/_macro/post.njk","hash":"434b3e76a040a816169e1929657e4176e7b8164c","modified":1664557711750},{"_id":"themes/next/scripts/filters/minify.js","hash":"f160e39943e39d7276da86adb47c3f08e5f22c7a","modified":1664557711686},{"_id":"themes/next/scripts/tags/button.js","hash":"c6ad2ed544fbb25ecb5d820c36e76302504271b7","modified":1664557711658},{"_id":"themes/next/scripts/tags/caniuse.js","hash":"935a311142a409c1896b3ae3f01fe7a9e2db1134","modified":1664557711658},{"_id":"themes/next/scripts/tags/center-quote.js","hash":"92c19d796bdb3320df9caea59bf52df7a95d9da9","modified":1664557711662},{"_id":"themes/next/scripts/tags/index.js","hash":"17f9451ce1f10f78437f52218757d38d4e1591b0","modified":1664557711678},{"_id":"themes/next/scripts/tags/group-pictures.js","hash":"9ed799c329abf830f623689d7e136991256a24ca","modified":1664557711674},{"_id":"themes/next/scripts/tags/label.js","hash":"8a73348186113bae0a51ea2f891c1bb882fab05a","modified":1664557711678},{"_id":"themes/next/scripts/tags/link-grid.js","hash":"18a483c2d5afd701f6080ffdddf2d1321370336c","modified":1664557711682},{"_id":"themes/next/scripts/tags/note.js","hash":"7b94ddb46b7d4b0fe815f2fbe4bd375f07f55363","modified":1664557711690},{"_id":"themes/next/scripts/tags/mermaid.js","hash":"4fb01ca650fa8b256b8d48f50dc1b18350bd3d6d","modified":1664557711686},{"_id":"themes/next/scripts/tags/pdf.js","hash":"344636b6fd7e27e8831c1e194039afc0d61931cd","modified":1664557711690},{"_id":"themes/next/scripts/tags/video.js","hash":"2ee926448583be8f95af1f2884ae2c9c4830151d","modified":1664557711698},{"_id":"themes/next/scripts/helpers/navigation.js","hash":"78107021101553c3d23e89290f7530b60cf4aa86","modified":1664557711686},{"_id":"themes/next/scripts/helpers/next-config.js","hash":"226fccbe9c93265e65a300e3cb4bf6f9065cfdd7","modified":1664557711686},{"_id":"themes/next/scripts/helpers/font.js","hash":"3394185a7f0393c16ce52c8028f90da3e9239c55","modified":1664557711674},{"_id":"themes/next/scripts/helpers/next-vendors.js","hash":"afdd6a188a74c188f0dd154fac70efd4080ca262","modified":1664557711690},{"_id":"themes/next/scripts/helpers/next-url.js","hash":"a11b71ba0c5012e2cdcab31c15439156b215563e","modified":1664557711686},{"_id":"themes/next/layout/_partials/head/head-unique.njk","hash":"8da52a144060db1a0a088ccb2e6cc8376d1fce70","modified":1664557711738},{"_id":"themes/next/scripts/helpers/engine.js","hash":"d292b78485e8e8055712b0ed6de7cf559c5fbdcd","modified":1664557711670},{"_id":"themes/next/layout/_partials/head/head.njk","hash":"0ba2bf0266f1fcb8edbd961869f8521b29685c56","modified":1664557711738},{"_id":"themes/next/layout/_partials/header/index.njk","hash":"650de421a8ce4cf685428ffbe0087ff84cbd1356","modified":1664557711738},{"_id":"themes/next/layout/_partials/header/brand.njk","hash":"aff4613756456be26415febc668860fdab8d33c5","modified":1664557711726},{"_id":"themes/next/layout/_partials/header/menu-item.njk","hash":"41a8b0cc16f60fa085cb719d07216d86b6bc4bf8","modified":1664557711742},{"_id":"themes/next/layout/_partials/header/menu.njk","hash":"ee6fc2f111572d3eeab0a2fecbb2d6b3e37ab26b","modified":1664557711742},{"_id":"themes/next/layout/_partials/header/sub-menu.njk","hash":"06480d8ec5f0b87eafd47f082f07968d7282dd5c","modified":1664557711754},{"_id":"themes/next/scripts/tags/tabs.js","hash":"0eabe51da40b4b13e16419c8fe02452d9a4fef73","modified":1664557711694},{"_id":"themes/next/layout/_partials/page/breadcrumb.njk","hash":"89825e75cc45e9709fa6ba89883669eedaff6f46","modified":1664557711726},{"_id":"themes/next/layout/_partials/search/index.njk","hash":"8f6f256ab3b351ffc80f1f3f1d9834e9a7cfac31","modified":1664557711738},{"_id":"themes/next/layout/_partials/search/localsearch.njk","hash":"661f7acae43f0be694266323320f977d84119abe","modified":1664557711742},{"_id":"themes/next/layout/_partials/page/tags.njk","hash":"a18d1598e36cc72f2b0b24c3cc3c5990dfaa3254","modified":1664557711754},{"_id":"themes/next/layout/_partials/search/algolia-search.njk","hash":"efb2b6f19df02ba5ae623a1f274fff52aed21e6f","modified":1664557711722},{"_id":"themes/next/layout/_partials/post/post-copyright.njk","hash":"133942922e34abae9e4de7ea5591d77c0caa4b37","modified":1664557711750},{"_id":"themes/next/layout/_partials/post/post-followme.njk","hash":"154df0bb323c332d8c25343f258ee865e5553423","modified":1664557711750},{"_id":"themes/next/layout/_partials/post/post-footer.njk","hash":"bde2c7356d9362972bde41cc206d5816f8ed714d","modified":1664557711750},{"_id":"themes/next/layout/_partials/post/post-related.njk","hash":"57eca76cfbbe9a65bc2a77f1deebf003ed335673","modified":1664557711750},{"_id":"themes/next/layout/_partials/post/post-reward.njk","hash":"002b51d0cae3f2e2e008bdc58be90c728282de5b","modified":1664557711750},{"_id":"themes/next/layout/_third-party/analytics/baidu-analytics.njk","hash":"6215309aee028dcb734452beec448c5afb6c63fc","modified":1664557711726},{"_id":"themes/next/layout/_third-party/analytics/cloudflare.njk","hash":"a5b8297c2c383124dd6a56e256ecc0c0dcf489be","modified":1664557711730},{"_id":"themes/next/layout/_partials/post/post-meta.njk","hash":"9fa47e4fb342811da590ee4adc91cf81118c0a39","modified":1664557711750},{"_id":"themes/next/layout/_third-party/analytics/growingio.njk","hash":"8afaa772c390bd9d53a5cff9645ac3168334eb98","modified":1664557711738},{"_id":"themes/next/layout/_partials/sidebar/site-overview.njk","hash":"3d8591bb92df77ceb9d5b07bc76da1ca89e5bd76","modified":1664557711754},{"_id":"themes/next/layout/_third-party/analytics/google-analytics.njk","hash":"d89066ff53879693f023e540d59c86137172c529","modified":1664557711738},{"_id":"themes/next/layout/_third-party/analytics/index.njk","hash":"314805f0186e9f6208c845f0757fdb7891c540f6","modified":1664557711738},{"_id":"themes/next/layout/_third-party/analytics/matomo.njk","hash":"4e89648a8ec8194c5823064cbca39c938a799006","modified":1664557711742},{"_id":"themes/next/layout/_third-party/analytics/microsoft-clarity.njk","hash":"9dc00fcb0a05899f048eace9f9160b78956655d5","modified":1664557711746},{"_id":"themes/next/layout/_third-party/chat/gitter.njk","hash":"f8cc14b7aa949999a1faaeb7855e2f20b59a386d","modified":1664557711738},{"_id":"themes/next/layout/_third-party/chat/tidio.njk","hash":"02aab857c27fc103216029be991688b12a73a525","modified":1664557711754},{"_id":"themes/next/layout/_third-party/comments/changyan.njk","hash":"d1c950f8fbdf85e7a3eae5463767a89e858e8220","modified":1664557711730},{"_id":"themes/next/layout/_third-party/comments/disqus.njk","hash":"9375b19a89b7fa9474e558d085af5448d4c5c50c","modified":1664557711734},{"_id":"themes/next/layout/_third-party/chat/chatra.njk","hash":"d7263fca16d0278ccf1f6aa1c6df6902a6344a09","modified":1664557711730},{"_id":"themes/next/layout/_third-party/comments/disqusjs.njk","hash":"0749cb6902baecdfd01f779a2a2513f6d2f6a823","modified":1664557711734},{"_id":"themes/next/layout/_third-party/comments/isso.njk","hash":"64cc3bdaf644fd32c0d0a247f29f5b6904da9af3","modified":1664557711738},{"_id":"themes/next/layout/_third-party/comments/livere.njk","hash":"3b13b09fba84ec6000886890a6710736a2b8fafe","modified":1664557711738},{"_id":"themes/next/layout/_third-party/math/index.njk","hash":"abf37fc55aa86702118e8fdf5bf2d389dd589aa0","modified":1664557711738},{"_id":"themes/next/layout/_third-party/comments/utterances.njk","hash":"5a94032bc3512a10ad4328fc19ec07b819a1d687","modified":1664557711754},{"_id":"themes/next/layout/_third-party/math/katex.njk","hash":"1ebf658690468ea197bdd0416eb7cfa4bd0b083a","modified":1664557711738},{"_id":"themes/next/layout/_third-party/math/mathjax.njk","hash":"3677017fd4572b158311f5f5d870590ab25184e0","modified":1664557711742},{"_id":"themes/next/layout/_third-party/comments/gitalk.njk","hash":"b63b7e2ede0d3e66e732fa1a06bda9b19e1e85d4","modified":1664557711734},{"_id":"themes/next/layout/_third-party/search/algolia-search.njk","hash":"24ed76e0c72a25ac152820c750a05826a706b6f4","modified":1664557711722},{"_id":"themes/next/layout/_third-party/search/localsearch.njk","hash":"e45ea3542cdc9ed7ec8447b5e6f35df4c5e82758","modified":1664557711742},{"_id":"themes/next/layout/_third-party/statistics/firestore.njk","hash":"d32ebe94560fa95824478ebbff531bffc47b194d","modified":1664557711734},{"_id":"themes/next/layout/_third-party/statistics/busuanzi-counter.njk","hash":"a4bc501da0f22f7e420f0ca47e83988ce90b1368","modified":1664557711730},{"_id":"themes/next/layout/_third-party/statistics/index.njk","hash":"568ddf7955d11d93fb5e842b403a7ac8b1b7fdb1","modified":1664557711738},{"_id":"themes/next/layout/_third-party/statistics/lean-analytics.njk","hash":"2446e748cdc102c78492216319ac02148db7daf6","modified":1664557711738},{"_id":"themes/next/layout/_third-party/tags/mermaid.njk","hash":"099e031f52fb8e47b3af5b2684737efc9e643ee7","modified":1664557711746},{"_id":"themes/next/layout/_third-party/tags/pdf.njk","hash":"2c81984cc4f5123103460442f6e046f5b6c97127","modified":1664557711750},{"_id":"themes/next/source/css/_variables/Gemini.styl","hash":"96e0a7c2a65ce68215e17e369085b2ea2f1334f2","modified":1664557711782},{"_id":"themes/next/source/css/_variables/Muse.styl","hash":"e3be898f5ebcf435a26542653a9297ff2c71aeb0","modified":1664557711794},{"_id":"themes/next/source/css/_variables/Mist.styl","hash":"e1fbf169b9b6a194b518240cbd06ec3c48b83d61","modified":1664557711794},{"_id":"themes/next/source/css/_variables/Pisces.styl","hash":"c65536a128b9bc9dbe2fbb1b235a3cded2891002","modified":1664557711798},{"_id":"themes/next/source/images/custom/about.txt","hash":"7c7ab79781501adfa608c9268eac2c29aecb652c","modified":1664554010800},{"_id":"themes/next/layout/_partials/page/categories.njk","hash":"17156d99941f28a225951ffdcfa9a115e20dc2d2","modified":1664557711730},{"_id":"themes/next/source/css/_variables/base.styl","hash":"163c7441d777bee87042d475e6ce0fde199add28","modified":1664557711774},{"_id":"themes/next/source/images/custom/apple-touch-icon.png","hash":"1d2628643a57fa01b2cf603e37fe46f741b17a9b","modified":1664554010784},{"_id":"themes/next/source/images/custom/favicon-16x16.png","hash":"e005396ad704e1e7577d18524612a0a408df0305","modified":1664554010796},{"_id":"themes/next/source/images/custom/favicon-32x32.png","hash":"94dcb555fa863cd068c257fe0098968c9b1c425d","modified":1664554010784},{"_id":"themes/next/source/images/custom/android-chrome-192x192.png","hash":"9cf95853b8ea6a2db166d106b806290647a5b365","modified":1664554010800},{"_id":"themes/next/source/images/custom/site.webmanifest","hash":"bf31baf91bdd2fcde24a45e3f2a1be33733c6f69","modified":1664554010796},{"_id":"themes/next/source/js/third-party/fancybox.js","hash":"c098d14e65dd170537134358d4b8359ad0539c2c","modified":1664557711670},{"_id":"themes/next/source/js/third-party/pace.js","hash":"0ef04218b93561ba4d0ff420d556c3d90a756d32","modified":1664557711690},{"_id":"themes/next/source/images/custom/android-chrome-512x512.png","hash":"f9a9d3aa252e09a82c15c97c74b07af4fcb3a3a0","modified":1664554010800},{"_id":"themes/next/source/js/third-party/quicklink.js","hash":"eed02e6fced8e5a653077205d4d4d7834ca71472","modified":1664557711694},{"_id":"themes/next/source/images/custom/favicon.ico","hash":"eff146afd5ff3aefb24e0836bf5059d40416e8f4","modified":1664554010796},{"_id":"themes/next/source/js/third-party/rating.js","hash":"4e92c2d107ba47b47826829f9668030d5ea9bfb8","modified":1664557711694},{"_id":"themes/next/scripts/events/lib/config.js","hash":"c8b59b404f5d2a0b3b5cd1a6c9a10af5f30e43b5","modified":1664557711666},{"_id":"themes/next/source/js/schemes/muse.js","hash":"9794bd4fc6a458322949d6a0ade89cd1026bc69f","modified":1664557711686},{"_id":"themes/next/source/images/custom/ranfang.jpg","hash":"7786cd44c4157beb7133c37a33135629b120f223","modified":1664554010776},{"_id":"themes/next/scripts/events/lib/injects.js","hash":"d987709267a1bc6e5014411e9983d7c49c102c16","modified":1664557711678},{"_id":"themes/next/scripts/events/lib/navigation.js","hash":"dd3562686d95a50375e6fd32e717ccb0d99c1e3d","modified":1664557711686},{"_id":"themes/next/scripts/events/lib/highlight.js","hash":"6aec7b2c38c50989a23bfaa0d560e75c7f553e12","modified":1664557711678},{"_id":"themes/next/scripts/filters/comment/changyan.js","hash":"7fa8701c86485b2fe7324e017101a32417902397","modified":1664557711662},{"_id":"themes/next/scripts/events/lib/vendors.js","hash":"64e4024376b51fe81be7ad80235abdf0a83853bd","modified":1664557711694},{"_id":"themes/next/scripts/events/lib/utils.js","hash":"ec996d0673f766167c86df0966e9da1ae036e103","modified":1664557711694},{"_id":"themes/next/scripts/filters/comment/common.js","hash":"19a402a225c31edffc50f202a14e0d582d3db23e","modified":1664557711666},{"_id":"themes/next/scripts/filters/comment/default-config.js","hash":"93ee5f9109dad885dc38c49bcee630c10f9dce6e","modified":1664557711666},{"_id":"themes/next/scripts/filters/comment/disqus.js","hash":"7f71d6b271ba65ff333d5682e7575711d368c0d2","modified":1664557711666},{"_id":"themes/next/scripts/filters/comment/disqusjs.js","hash":"62faf6b0b0020066a0dec1f0123cf1fee3198e7e","modified":1664557711670},{"_id":"themes/next/scripts/filters/comment/gitalk.js","hash":"7bb7dafdd7f6bca8464b54e17e552ce7f1714195","modified":1664557711674},{"_id":"themes/next/scripts/filters/comment/isso.js","hash":"ff8b5b5145220a17d0ecd9508ba9bd2d3b2da47d","modified":1664557711678},{"_id":"themes/next/scripts/filters/comment/utterances.js","hash":"d3bded697bc32dace689d2a6dfb6eb7514169d15","modified":1664557711694},{"_id":"themes/next/scripts/filters/comment/livere.js","hash":"5a07d8bb52bc1d51a624ca8db54be144566c306b","modified":1664557711682},{"_id":"themes/next/source/css/_schemes/Mist/_header.styl","hash":"4817e77577896ab5c0da434549917ee703a3f4cf","modified":1664557711766},{"_id":"themes/next/source/css/_schemes/Mist/_layout.styl","hash":"5604ac1e161099a4d3e5657d53507268866dc717","modified":1664557711770},{"_id":"themes/next/source/css/_schemes/Gemini/index.styl","hash":"fd49b521d67eaccc629f77b4e095cb7310327565","modified":1664557711790},{"_id":"themes/next/source/css/_schemes/Mist/_menu.styl","hash":"fb550935d374e0bdf1097fce187337dc05cad3e1","modified":1664557711770},{"_id":"themes/next/source/css/_schemes/Mist/_posts-expand.styl","hash":"be6cf377ae8f4a01ee76f9b3014e74161d4d5d17","modified":1664557711774},{"_id":"themes/next/source/css/_schemes/Mist/index.styl","hash":"ab16a3dcdc0393b9b582ef59dcc13db9320e917c","modified":1664557711790},{"_id":"themes/next/source/css/_schemes/Muse/_header.styl","hash":"06080fd963c904d96c00eff098a284e337953013","modified":1664557711770},{"_id":"themes/next/source/css/_schemes/Muse/_layout.styl","hash":"82a29572dd90451f75358a2ee2522b87304a0bb8","modified":1664557711770},{"_id":"themes/next/source/css/_schemes/Muse/_menu.styl","hash":"b7f48be3c43bfa393d62142544a5487a67871713","modified":1664557711774},{"_id":"themes/next/layout/_partials/page/schedule.njk","hash":"0f4bc8e257da60f77c0c1738607b2bde55810684","modified":1664557711750},{"_id":"themes/next/source/css/_schemes/Muse/index.styl","hash":"6ad168288b213cec357e9b5a97674ff2ef3a910c","modified":1664557711790},{"_id":"themes/next/source/css/_schemes/Muse/_sub-menu.styl","hash":"c48ccd8d6651fe1a01faff8f01179456d39ba9b1","modified":1664557711774},{"_id":"themes/next/source/css/_schemes/Muse/_sidebar.styl","hash":"944364893bd7160d954c10ba931af641c91515a4","modified":1664557711774},{"_id":"themes/next/source/css/_schemes/Pisces/_header.styl","hash":"b741ab96e73370711c63a6581159f2ea8b5bfa1b","modified":1664557711770},{"_id":"themes/next/source/css/_schemes/Pisces/_menu.styl","hash":"72dc825c50357402c342d62ab60fc0c478ab6bc1","modified":1664557711774},{"_id":"themes/next/source/css/_schemes/Pisces/_sub-menu.styl","hash":"778ed2ad5643b93970c95626b325defeb586733f","modified":1664557711774},{"_id":"themes/next/source/css/_schemes/Pisces/_sidebar.styl","hash":"d9141e6e14a56b5952488101e9a8388c2170e270","modified":1664557711774},{"_id":"themes/next/source/css/_schemes/Pisces/_layout.styl","hash":"6eee86c8f0175d6c09e434053516cd8556f78d44","modified":1664557711770},{"_id":"themes/next/source/css/_schemes/Pisces/index.styl","hash":"8000075b227749a7495eaf417cac6ccfbe441580","modified":1664557711790},{"_id":"themes/next/source/css/_common/components/back-to-top.styl","hash":"bab653bcf226311381e8411a0492202f1bf1fce9","modified":1664557711774},{"_id":"themes/next/source/css/_common/components/index.styl","hash":"fe1868f47681e00a33a96199302be85377282f63","modified":1664557711782},{"_id":"themes/next/source/css/_common/outline/index.styl","hash":"8e34df131830d4fa3725e4590a672ba1cf1903e5","modified":1664557711786},{"_id":"themes/next/source/css/_common/components/reading-progress.styl","hash":"90a86045a33c1bae49fc2f6fa1e1b53170c7f77b","modified":1664557711798},{"_id":"themes/next/source/css/_common/scaffolding/buttons.styl","hash":"a042571d85ff7265f799004239a45f36b716b8a6","modified":1664557711782},{"_id":"themes/next/source/css/_common/outline/mobile.styl","hash":"64775c729512b30b144ab5ae9dc4a4dfd4e13f35","modified":1664557711794},{"_id":"themes/next/source/css/_common/scaffolding/comments.styl","hash":"e4fecc889ba3317a64e9abba5842c79dff9b7827","modified":1664557711782},{"_id":"themes/next/source/css/_common/scaffolding/base.styl","hash":"d0a7c99095f490b0d2ed6b1be43d435960798cec","modified":1664557711774},{"_id":"themes/next/source/css/_common/scaffolding/index.styl","hash":"523fb7b653b87ae37fc91fc8813e4ffad87b0d7e","modified":1664557711790},{"_id":"themes/next/source/css/_common/scaffolding/tables.styl","hash":"e840b23d33023e6d45e018f6e84b683dd56efd8d","modified":1664557711802},{"_id":"themes/next/source/css/_common/scaffolding/pagination.styl","hash":"b5c7782368889fa9fd93807d28ff2daf270e3703","modified":1664557711798},{"_id":"themes/next/source/css/_common/scaffolding/toggles.styl","hash":"572a41499391677d84b16d8dbd6a996a3d5ce041","modified":1664557711806},{"_id":"themes/next/source/js/third-party/analytics/baidu-analytics.js","hash":"f629acc46ff40c071ffd31b77d5c7616f0fdd778","modified":1664557711658},{"_id":"themes/next/source/js/third-party/analytics/growingio.js","hash":"78dd3cf04082b7dbe6246e404b2aa8e726922402","modified":1664557711678},{"_id":"themes/next/source/js/third-party/analytics/google-analytics.js","hash":"59684383385059dc4f8a1ff85dbbeb703bcdbcb5","modified":1664557711674},{"_id":"themes/next/source/css/_common/scaffolding/normalize.styl","hash":"b56367ea676ea8e8783ea89cd4ab150c7da7a060","modified":1664557711794},{"_id":"themes/next/source/js/third-party/analytics/matomo.js","hash":"c6a25b26a1443caa70b47fd3dfa282271574deb5","modified":1664557711686},{"_id":"themes/next/source/js/third-party/chat/gitter.js","hash":"cc38c94125f90dadde11b5ebac7d8bf99a1a08a2","modified":1664557711674},{"_id":"themes/next/source/js/third-party/chat/chatra.js","hash":"c32180522788c10e51df1803aa6842ef0432ddc9","modified":1664557711662},{"_id":"themes/next/layout/_partials/page/page-header.njk","hash":"7ed4f102a1825195cff8d7995bf9219f323a9034","modified":1664557711746},{"_id":"themes/next/source/js/third-party/chat/tidio.js","hash":"b0079f6a4601e06ca6fe46e83a2f5af553e9bc3c","modified":1664557711694},{"_id":"themes/next/source/js/third-party/comments/changyan.js","hash":"260d1a77d6a3bb33a579d3e4cca1997003e799b5","modified":1664557711662},{"_id":"themes/next/source/js/third-party/comments/disqusjs.js","hash":"33a82207a15aad9d1c8fb2251f9e3eba50452932","modified":1664557711670},{"_id":"themes/next/source/js/third-party/comments/isso.js","hash":"753a873b6f566aff5ba77ca23f91b78eb880ca64","modified":1664557711678},{"_id":"themes/next/source/js/third-party/comments/disqus.js","hash":"e1cc671b0d524864fd445e3ab4ade9ee6d07e565","modified":1664557711670},{"_id":"themes/next/source/js/third-party/comments/livere.js","hash":"2247d88c934c765c43013337860774aaa99f0b31","modified":1664557711682},{"_id":"themes/next/source/js/third-party/comments/gitalk.js","hash":"0ec038cf83e8ec067534f16a54041e47a3c1e59a","modified":1664557711674},{"_id":"themes/next/source/js/third-party/comments/utterances.js","hash":"f67f90eb03e284c82da2b8cf2f1e31801813c16d","modified":1664557711694},{"_id":"themes/next/source/js/third-party/math/katex.js","hash":"83c54ee536e487a1031783443fe0cb63b1b4767e","modified":1664557711678},{"_id":"themes/next/source/js/third-party/math/mathjax.js","hash":"5c749b9c1c3bb738122d0516211ecff6496d4907","modified":1664557711686},{"_id":"themes/next/source/js/third-party/search/algolia-search.js","hash":"fdb7b7cef1a147d897e7f7cd8903b58368ec2062","modified":1664557711654},{"_id":"themes/next/source/js/third-party/statistics/firestore.js","hash":"411a72df581f5b21317dc28633c7993207eb9e1c","modified":1664557711674},{"_id":"themes/next/source/js/third-party/statistics/lean-analytics.js","hash":"835cbf54c49ef1327f47df70ff2636ad36b6f57d","modified":1664557711682},{"_id":"themes/next/source/js/third-party/search/local-search.js","hash":"4536cb6d0a9bbaaa86fab3fa0101f6a3a3ec5a76","modified":1664557711682},{"_id":"themes/next/source/css/_common/components/post/post-followme.styl","hash":"fc1a7bac6493f24aa50665574f37f3dd954f210c","modified":1664557711798},{"_id":"themes/next/source/js/third-party/tags/mermaid.js","hash":"f27d817b0c2138dd3215b1f46af0753f60a008f3","modified":1664557711686},{"_id":"themes/next/source/css/_common/components/post/post-footer.styl","hash":"1d284f3ea03ba9b4feb76b375e539a8e0bccf1c3","modified":1664557711798},{"_id":"themes/next/source/css/_common/components/post/post-gallery.styl","hash":"aa366d37389760c8595529b850f461569577a1c5","modified":1664557711798},{"_id":"themes/next/source/css/_common/components/post/post-collapse.styl","hash":"ec37a36e94ba791663607a5022f763915778578f","modified":1664557711798},{"_id":"themes/next/source/css/_common/components/post/post-header.styl","hash":"010c901e4ef49a606f8a350efbf09044e76d2ff3","modified":1664557711798},{"_id":"themes/next/source/css/_common/components/post/post-nav.styl","hash":"9ac6f477177264c26a46e8333b8456720a0444dc","modified":1664557711798},{"_id":"themes/next/source/css/_common/components/post/post-reward.styl","hash":"07cff69f2d57e6321595f64c16d8b763dc88df6a","modified":1664557711798},{"_id":"themes/next/source/css/_common/components/post/post-widgets.styl","hash":"b6677dc2a2368084ab82bb4f145ac79e5966c150","modified":1664557711798},{"_id":"themes/next/source/css/_common/components/post/post-body.styl","hash":"d757768a58743601d0d84158ba955eb15d4c3c01","modified":1664557711798},{"_id":"themes/next/source/css/_common/components/pages/breadcrumb.styl","hash":"8afdc311c6b8db121758371f95cf1c5e77354f42","modified":1664557711782},{"_id":"themes/next/source/css/_common/components/pages/categories.styl","hash":"b6e2eb1550a7845cb2adf86081a4ab6c7bde1e68","modified":1664557711782},{"_id":"themes/next/source/css/_common/components/pages/index.styl","hash":"7504dbc5c70262b048143b2c37d2b5aa2809afa2","modified":1664557711782},{"_id":"themes/next/source/css/_common/components/pages/schedule.styl","hash":"6b816c2511242ee503fb5f34cd3e4dcdafc06b85","modified":1664557711798},{"_id":"themes/next/source/css/_common/components/third-party/disqusjs.styl","hash":"c2326ee3e8b724d99c24a818ddee32813ea5bf89","modified":1664557711782},{"_id":"themes/next/source/css/_common/components/third-party/gitalk.styl","hash":"070737d101e7cd58e997e8c7af09958268c43a21","modified":1664557711782},{"_id":"themes/next/source/css/_common/components/third-party/gitter.styl","hash":"35104dc6883a61c31e0e368dac8ac2f697be62fe","modified":1664557711782},{"_id":"themes/next/source/css/_common/components/third-party/index.styl","hash":"979486a41a81f2a9fd8b0b87c4f87d6416c68c7d","modified":1664557711782},{"_id":"themes/next/source/css/_common/components/third-party/math.styl","hash":"9d995eb4871a6c273d9d51558676a1fdabf69e72","modified":1664557711790},{"_id":"themes/next/source/css/_common/components/pages/tag-cloud.styl","hash":"1a81d1a71fcf0699629ce6e72dfd0a15f3a2dd0a","modified":1664557711806},{"_id":"themes/next/source/css/_common/components/third-party/search.styl","hash":"e72799ce3f9b79753e365b2f8c8ef6c310668d4a","modified":1664557711798},{"_id":"themes/next/source/css/_common/components/third-party/utterances.styl","hash":"56d90ae0559caa55b75f3c300ff2711f9ed65fc4","modified":1664557711806},{"_id":"themes/next/source/css/_common/components/third-party/related-posts.styl","hash":"41ed817e1eb64078074e245e771446ee041e5790","modified":1664557711798},{"_id":"themes/next/source/css/_common/outline/header/bookmark.styl","hash":"e74f4bb47a101b014ee2a1783c87f3b87323f9a0","modified":1664557711778},{"_id":"themes/next/source/css/_common/outline/footer/index.styl","hash":"8b9407e5cfd0571ef8de7df19022b268f962fa2f","modified":1664557711786},{"_id":"themes/next/source/css/_common/outline/header/github-banner.styl","hash":"38c64c2d04e46848382bfa246a0e9c508294767b","modified":1664557711782},{"_id":"themes/next/source/css/_common/components/post/index.styl","hash":"d0805a763176b3c0003967401644f41dfe3bc9e8","modified":1664557711782},{"_id":"themes/next/source/css/_common/outline/header/index.styl","hash":"ff642130354a0b3be0d708c43044ed4d710b5e83","modified":1664557711786},{"_id":"themes/next/source/css/_common/outline/header/menu.styl","hash":"392fd53a8dd4e3f33a853ebb24290a622300e0ff","modified":1664557711790},{"_id":"themes/next/source/css/_common/outline/header/site-meta.styl","hash":"759e582d34d08e3386c55d87a835a9523608619f","modified":1664557711802},{"_id":"themes/next/source/css/_common/outline/header/site-nav.styl","hash":"bf3ad8b4268f763a1e26377681644887694bc009","modified":1664557711802},{"_id":"themes/next/source/css/_common/outline/sidebar/index.styl","hash":"cee43480eba028c37d51cb620c2d81486aa24e01","modified":1664557711790},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-author-links.styl","hash":"52fc98b1435129eb3edb9293ced9e507741f1350","modified":1664557711798},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-author.styl","hash":"5b38ac4a0f1ade0e681aff0e3366c481d9cf3dcd","modified":1664557711798},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-blogroll.styl","hash":"9950c3188a28e1c63b5498b7bdcd14b12ace3e28","modified":1664557711798},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-button.styl","hash":"b926e368f702f8686aaa2eb98d3d2e533418958c","modified":1664557711798},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-dimmer.styl","hash":"fbdb63c6a8887d19b7137325ba7d6806f728139c","modified":1664557711798},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-nav.styl","hash":"ee94a1a27090ad24e3ed579093088d97ff96d77d","modified":1664557711798},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-toc.styl","hash":"021a37cf178440cc341940a299d3bca359996c6b","modified":1664557711802},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-toggle.styl","hash":"3103b81fc76b59e1e2c161e2c484625c770ed66f","modified":1664557711802},{"_id":"themes/next/source/css/_common/outline/sidebar/site-state.styl","hash":"26dd0adfcb1db6df29c6090c8d7e9b5a43583fb0","modified":1664557711802},{"_id":"themes/next/source/css/_common/scaffolding/highlight/copy-code.styl","hash":"670fc109b56a010b166b86b616823a1aae97a738","modified":1664557711782},{"_id":"themes/next/source/css/_common/scaffolding/highlight/index.styl","hash":"f2328caa94645836e06fb39a6a9c9a84ed68a8b5","modified":1664557711790},{"_id":"themes/next/source/css/_common/scaffolding/tags/blockquote-center.styl","hash":"d6418fd2bbfba7b73ddf11ec62db9637fdf5d8af","modified":1664557711778},{"_id":"themes/next/source/css/_common/scaffolding/tags/group-pictures.styl","hash":"393ff96234e4196b569d4b11496774eb78e147de","modified":1664557711782},{"_id":"themes/next/source/css/_common/scaffolding/tags/label.styl","hash":"debee14539272fbe3835a7d3853af2230baa3501","modified":1664557711790},{"_id":"themes/next/source/css/_common/scaffolding/tags/link-grid.styl","hash":"7f8a7345e6537a62cd9e9a94c8f7065b541d9b04","modified":1664557711790},{"_id":"themes/next/source/js/third-party/tags/pdf.js","hash":"af78c22f0e61c8c8aa8794e585e0d632c6d4fcb8","modified":1664557711690},{"_id":"themes/next/source/css/_common/scaffolding/tags/mermaid.styl","hash":"48d35dba575a7c9e8845b16652e76b7d4a4646de","modified":1664557711794},{"_id":"themes/next/source/css/_common/scaffolding/tags/note.styl","hash":"d27fbf7799695295dd5860a161a13ac4d90c5ba4","modified":1664557711794},{"_id":"themes/next/source/css/_common/scaffolding/tags/index.styl","hash":"3f76c73a891bbc10679753e702feba9e8a5ffdd2","modified":1664557711790},{"_id":"themes/next/source/css/_common/scaffolding/tags/pdf.styl","hash":"b6654a1d7cf82577d8263faffee8af3ad4a5c0e8","modified":1664557711798},{"_id":"themes/next/source/css/_common/scaffolding/tags/tabs.styl","hash":"7a39bcce7274284e87388743db62afc847fe6897","modified":1664557711802},{"_id":"public/about/index.html","hash":"182ee286669daed0c79de9d390e2a244d2164a30","modified":1664560740610},{"_id":"public/cv/index.html","hash":"6293da49365dd03015886dbfb1272d272c9e09e5","modified":1664560740610},{"_id":"public/tags/index.html","hash":"94329d956e00456b17aa19d875a2f3c892f03d8b","modified":1664560740610},{"_id":"public/2022/10/01/hello-world/index.html","hash":"d9896548a09a3b6a0126f34c609e725cb0b0a1dd","modified":1664560740610},{"_id":"public/categories/Learning/index.html","hash":"b3388a8c24c9d87d36ae12d957d7b55598d7b9a8","modified":1664560740610},{"_id":"public/tags/c/index.html","hash":"7b2937d9415a1fe9a95168000cdf366b33049660","modified":1664560740610},{"_id":"public/tags/programming-basic/index.html","hash":"f789bbcdc9a00aeadf2de556c336aaac5132beed","modified":1664560740610},{"_id":"public/tags/embedded/index.html","hash":"36e97f7b6ec10246e183f64cb06a8eb31325c0bd","modified":1664560740610},{"_id":"public/tags/Linux/index.html","hash":"b438961b01826f0ad224c0f174cce69616c5e03b","modified":1664560740610},{"_id":"public/2022/09/29/Cpp-Learning-Notes-Template/index.html","hash":"3ebb1157e0a37405b15359aba457cb7e48f4feee","modified":1664560740610},{"_id":"public/2022/09/29/Makefile-Learning-Notes/index.html","hash":"05f5bd045b2429344f7cfa7da8876b1a14fd2bcf","modified":1664560740610},{"_id":"public/index.html","hash":"97c5fa28b646b0b1a61835108d4ca804ae38fd2c","modified":1664560740610},{"_id":"public/archives/index.html","hash":"5edfc7599cddffebb928caccc39e86aa7a719113","modified":1664560740610},{"_id":"public/archives/2022/index.html","hash":"4f9e91582112a26dfd9503d6a0a63253b5304ffe","modified":1664560740610},{"_id":"public/archives/2022/09/index.html","hash":"f6b00aa3a581c912cf6178e1da9c5ca2d782a024","modified":1664560740610},{"_id":"public/archives/2022/10/index.html","hash":"30281e8d7ae6cbe0f5ab2114be01f943cf5b8246","modified":1664560740610},{"_id":"public/CNAME","hash":"e348bc0cd8452a13fcce50ed3d73f17456635949","modified":1664560740610},{"_id":"public/images/apple-touch-icon-next.png","hash":"2959dbc97f31c80283e67104fe0854e2369e40aa","modified":1664560740610},{"_id":"public/images/favicon-32x32-next.png","hash":"0749d7b24b0d2fae1c8eb7f671ad4646ee1894b1","modified":1664560740610},{"_id":"public/images/logo-algolia-nebula-blue-full.svg","hash":"b85e274207b1392782476a0430feac98db1e7da0","modified":1664560740610},{"_id":"public/images/logo.svg","hash":"2cb74fd3ea2635e015eabc58a8d488aed6cf6417","modified":1664560740610},{"_id":"public/images/avatar.gif","hash":"2dbc3e2f2d624b2ca1afe6edc2ca17307f1950c8","modified":1664560740610},{"_id":"public/images/favicon-16x16-next.png","hash":"943a0d67a9cdf8c198109b28f9dbd42f761d11c3","modified":1664560740610},{"_id":"public/images/custom/about.txt","hash":"7c7ab79781501adfa608c9268eac2c29aecb652c","modified":1664560740610},{"_id":"public/images/custom/android-chrome-192x192.png","hash":"9cf95853b8ea6a2db166d106b806290647a5b365","modified":1664560740610},{"_id":"public/images/custom/android-chrome-512x512.png","hash":"f9a9d3aa252e09a82c15c97c74b07af4fcb3a3a0","modified":1664560740610},{"_id":"public/images/custom/favicon-16x16.png","hash":"e005396ad704e1e7577d18524612a0a408df0305","modified":1664560740610},{"_id":"public/images/custom/apple-touch-icon.png","hash":"1d2628643a57fa01b2cf603e37fe46f741b17a9b","modified":1664560740610},{"_id":"public/images/custom/favicon-32x32.png","hash":"94dcb555fa863cd068c257fe0098968c9b1c425d","modified":1664560740610},{"_id":"public/images/custom/favicon.ico","hash":"eff146afd5ff3aefb24e0836bf5059d40416e8f4","modified":1664560740610},{"_id":"public/images/custom/site.webmanifest","hash":"bf31baf91bdd2fcde24a45e3f2a1be33733c6f69","modified":1664560740610},{"_id":"public/images/custom/ranfang.jpg","hash":"7786cd44c4157beb7133c37a33135629b120f223","modified":1664560740610},{"_id":"public/css/noscript.css","hash":"ec89b3425fbce20863d554c6fd495ea29c3c303d","modified":1664560740610},{"_id":"public/js/bookmark.js","hash":"0f563ffbf05fad30e854e413ab17ff7164ab5a53","modified":1664560740610},{"_id":"public/js/config.js","hash":"4c4ebbe3b3f3841a26f9d5af6d0ba8bc6da01c54","modified":1664560740610},{"_id":"public/js/comments.js","hash":"66ae2e26ea36a41b72c638ea8b220296638ae952","modified":1664560740610},{"_id":"public/js/comments-buttons.js","hash":"1a7344440321713426a0b2ab17e276b5bdf85ade","modified":1664560740610},{"_id":"public/js/pjax.js","hash":"919f5281c4a04d11cfd94573ecf57b3dbabd3cc8","modified":1664560740610},{"_id":"public/js/next-boot.js","hash":"da0f07f9eaaa83de70128b0feaea3fdadb90457a","modified":1664560740610},{"_id":"public/js/schedule.js","hash":"a1333258726caf84f368a8f8454639c7dc1626bb","modified":1664560740610},{"_id":"public/js/motion.js","hash":"f7c825cbff11885fa0dffa64824fd00e505d6a8d","modified":1664560740610},{"_id":"public/js/utils.js","hash":"200088bfd042f5304b2a04befab0829148845e0e","modified":1664560740610},{"_id":"public/js/third-party/fancybox.js","hash":"c098d14e65dd170537134358d4b8359ad0539c2c","modified":1664560740610},{"_id":"public/js/third-party/pace.js","hash":"0ef04218b93561ba4d0ff420d556c3d90a756d32","modified":1664560740610},{"_id":"public/js/third-party/quicklink.js","hash":"eed02e6fced8e5a653077205d4d4d7834ca71472","modified":1664560740610},{"_id":"public/js/third-party/rating.js","hash":"4e92c2d107ba47b47826829f9668030d5ea9bfb8","modified":1664560740610},{"_id":"public/js/third-party/analytics/baidu-analytics.js","hash":"f629acc46ff40c071ffd31b77d5c7616f0fdd778","modified":1664560740610},{"_id":"public/js/third-party/analytics/google-analytics.js","hash":"59684383385059dc4f8a1ff85dbbeb703bcdbcb5","modified":1664560740610},{"_id":"public/js/third-party/analytics/matomo.js","hash":"c6a25b26a1443caa70b47fd3dfa282271574deb5","modified":1664560740610},{"_id":"public/js/schemes/muse.js","hash":"9794bd4fc6a458322949d6a0ade89cd1026bc69f","modified":1664560740610},{"_id":"public/js/third-party/chat/chatra.js","hash":"c32180522788c10e51df1803aa6842ef0432ddc9","modified":1664560740610},{"_id":"public/js/third-party/analytics/growingio.js","hash":"78dd3cf04082b7dbe6246e404b2aa8e726922402","modified":1664560740610},{"_id":"public/js/third-party/chat/gitter.js","hash":"cc38c94125f90dadde11b5ebac7d8bf99a1a08a2","modified":1664560740610},{"_id":"public/js/third-party/chat/tidio.js","hash":"b0079f6a4601e06ca6fe46e83a2f5af553e9bc3c","modified":1664560740610},{"_id":"public/js/third-party/comments/changyan.js","hash":"260d1a77d6a3bb33a579d3e4cca1997003e799b5","modified":1664560740610},{"_id":"public/js/third-party/comments/disqus.js","hash":"e1cc671b0d524864fd445e3ab4ade9ee6d07e565","modified":1664560740610},{"_id":"public/js/third-party/comments/disqusjs.js","hash":"33a82207a15aad9d1c8fb2251f9e3eba50452932","modified":1664560740610},{"_id":"public/js/third-party/comments/gitalk.js","hash":"0ec038cf83e8ec067534f16a54041e47a3c1e59a","modified":1664560740610},{"_id":"public/js/third-party/comments/livere.js","hash":"2247d88c934c765c43013337860774aaa99f0b31","modified":1664560740610},{"_id":"public/js/third-party/comments/utterances.js","hash":"f67f90eb03e284c82da2b8cf2f1e31801813c16d","modified":1664560740610},{"_id":"public/js/third-party/math/katex.js","hash":"83c54ee536e487a1031783443fe0cb63b1b4767e","modified":1664560740610},{"_id":"public/js/third-party/math/mathjax.js","hash":"5c749b9c1c3bb738122d0516211ecff6496d4907","modified":1664560740610},{"_id":"public/js/third-party/search/algolia-search.js","hash":"fdb7b7cef1a147d897e7f7cd8903b58368ec2062","modified":1664560740610},{"_id":"public/js/third-party/search/local-search.js","hash":"4536cb6d0a9bbaaa86fab3fa0101f6a3a3ec5a76","modified":1664560740610},{"_id":"public/js/third-party/statistics/firestore.js","hash":"411a72df581f5b21317dc28633c7993207eb9e1c","modified":1664560740610},{"_id":"public/js/third-party/statistics/lean-analytics.js","hash":"835cbf54c49ef1327f47df70ff2636ad36b6f57d","modified":1664560740610},{"_id":"public/js/third-party/tags/mermaid.js","hash":"f27d817b0c2138dd3215b1f46af0753f60a008f3","modified":1664560740610},{"_id":"public/js/third-party/tags/pdf.js","hash":"af78c22f0e61c8c8aa8794e585e0d632c6d4fcb8","modified":1664560740610},{"_id":"public/js/third-party/comments/isso.js","hash":"753a873b6f566aff5ba77ca23f91b78eb880ca64","modified":1664560740610},{"_id":"public/css/main.css","hash":"26b389c91bad86c3c68339f5f1418abbcdba23ab","modified":1664560740610}],"Category":[{"name":"Learning","_id":"cl8oshjpt000416u7cq1l5ujr"}],"Data":[],"Page":[{"title":"about","date":"2022-09-29T17:01:49.000Z","_content":"\n- 👋 Hi, I’m @RanFang66\n- 🏫 I graduated from Harbin Institude of Technology with a master degree  of electrical engineering\n- 👀 I’m interested in embeded software development, Linux, raspberry PI, OpenCV, QT\n- 🌱 I’m currently learning QT, OpenCV and Japanese\n- 📫 You can reach me through ranfang66@gmail.com\n","source":"about/index.md","raw":"---\ntitle: about\ndate: 2022-09-30 01:01:49\n---\n\n- 👋 Hi, I’m @RanFang66\n- 🏫 I graduated from Harbin Institude of Technology with a master degree  of electrical engineering\n- 👀 I’m interested in embeded software development, Linux, raspberry PI, OpenCV, QT\n- 🌱 I’m currently learning QT, OpenCV and Japanese\n- 📫 You can reach me through ranfang66@gmail.com\n","updated":"2022-09-30T17:04:51.461Z","path":"about/index.html","comments":1,"layout":"page","_id":"cl8oshjpn000016u709sd979g","content":"<ul>\n<li>👋 Hi, I’m @RanFang66</li>\n<li>🏫 I graduated from Harbin Institude of Technology with a master degree  of electrical engineering</li>\n<li>👀 I’m interested in embeded software development, Linux, raspberry PI, OpenCV, QT</li>\n<li>🌱 I’m currently learning QT, OpenCV and Japanese</li>\n<li>📫 You can reach me through <a href=\"mailto:&#x72;&#x61;&#110;&#102;&#x61;&#110;&#x67;&#x36;&#x36;&#64;&#103;&#x6d;&#97;&#105;&#108;&#x2e;&#99;&#x6f;&#x6d;\">&#x72;&#x61;&#110;&#102;&#x61;&#110;&#x67;&#x36;&#x36;&#64;&#103;&#x6d;&#97;&#105;&#108;&#x2e;&#99;&#x6f;&#x6d;</a></li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<ul>\n<li>👋 Hi, I’m @RanFang66</li>\n<li>🏫 I graduated from Harbin Institude of Technology with a master degree  of electrical engineering</li>\n<li>👀 I’m interested in embeded software development, Linux, raspberry PI, OpenCV, QT</li>\n<li>🌱 I’m currently learning QT, OpenCV and Japanese</li>\n<li>📫 You can reach me through <a href=\"mailto:&#x72;&#x61;&#110;&#102;&#x61;&#110;&#x67;&#x36;&#x36;&#64;&#103;&#x6d;&#97;&#105;&#108;&#x2e;&#99;&#x6f;&#x6d;\">&#x72;&#x61;&#110;&#102;&#x61;&#110;&#x67;&#x36;&#x36;&#64;&#103;&#x6d;&#97;&#105;&#108;&#x2e;&#99;&#x6f;&#x6d;</a></li>\n</ul>\n"},{"title":"cv","date":"2022-09-29T17:03:36.000Z","_content":"","source":"cv/index.md","raw":"---\ntitle: cv\ndate: 2022-09-30 01:03:36\n---\n","updated":"2022-09-30T17:04:51.461Z","path":"cv/index.html","comments":1,"layout":"page","_id":"cl8oshjpr000216u7ee65fkta","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"tags","date":"2022-09-29T17:04:40.000Z","type":"tags","_content":"","source":"tags/index.md","raw":"---\ntitle: tags\ndate: 2022-09-30 01:04:40\ntype: tags\n---\n","updated":"2022-09-30T17:04:51.461Z","path":"tags/index.html","comments":1,"layout":"page","_id":"cl8oshjpv000616u7g0y13bp3","content":"","site":{"data":{}},"excerpt":"","more":""}],"Post":[{"title":"C++ Learning Notes-Template","date":"2022-09-29T11:33:35.000Z","_content":"\n## C++泛型编程----模板\n\n泛型程序设计（generic programming）是一种算法在实现时不指定具体要操作的数据的类型的程序设计方法。所谓“泛型”，指的是算法只要实现一遍，就能适用于多种数据类型。泛型程序设计方法的优势在于能够减少重复代码的编写。\n\n为了实现泛型编程, C++中支持模板的概念.模板就是将数据类型也作为一个参数传递到具体的算法实现中(类型参数化),这样就实现了算法和数据类型的分离,即针对不同的数据类型,同一个模板都能正确处理.\n\n<!--more-->\n\n## 函数模板\n\n所谓函数模板，实际上是建立一个通用函数，它所用到的数据的类型（包括返回值类型、形参类型、局部变量类型）可以不具体指定，而是用一个虚拟的类型来代替（实际上是用一个标识符来占位），等发生函数调用时再根据传入的实参来逆推出真正的类型。这个通用函数就称为**函数模板（Function Template）**。\n\n### **函数模板的定义**\n\n```c++\ntemplate <typename TName1, typename TName2, ...> 返回值类型 函数名(形参列表) \n{\n\t// 函数体中可使用类型参数    \n}\n```\n\ntemplate 是定义函数模板的关键字,后面紧跟尖括号,尖括号内用于声明类型参数,其中typename也是关键字,可以声明多个类型参数.template <typename T>这样的结构被称为模板头,模板头中声明的类型参数可以用在后面函数定义或声明的任何位置.需要注意的是,typename 关键字可以被class关键字替代.\n\n### **函数模板的调用**\n\n在调用函数模板时，可以不用显示的指明具体类型参数，编译器会自动根据实参的类型做类型推断得到模板中的类型参数的类型，这个过程称为模板实参推断。对于模板实参推断，我们要注意函数调用时的类型转换问题。函数模板调用时，参数的类型转换相较于普通函数调用会收到更多限制，仅能进行[const]转换和数组或者函数指针转换，其他都不能应用于模板函数。例如有如下5个函数模板：\n\n```c++\ntemplate<typename T> void func1(T a, T b);\ntemplate<typename T> void func2(T *buff);\ntemplate<typename T> void func3(const T &stu);\ntemplate<typename T> void func4(T a);\ntemplate<typename T> void func5(T &a);\n```\n\n当按照如下代码进行调用时：\n\n```c++\nint name[20];\nStudent Stu1(\"XiaoMing\", 20, 96.5);\n\nfunc1(12.5, 30);   \t// Error\nfunc2(name);\t\t// T == int\nfunc3(stu1);\t\t// T == Student\nfunc4(name);\t\t// T == int*\nfunc5(name);\t\t// T == int[20]\n```\n\n对于func1的调用由于第一个参数为double类型，第二个为int类型，编译器不知道T应该为哪个类型，并且也不会做自动类型的转换，所以调用出错。\n\n对于func2的调用，name数组会转换为指针。所以T对应的类型为int。\n\n对于func3的调用，stu1参数会从非const转换为const，所以T对用的类型为Student类。\n\n对于func4的调用，name参数会从数组类型int [20]转换为指针int *, 所以T对应的类型为int *;\n\n对于func5的调用，name参数作为引用类型时不会从数组类型转换为指针，仍然为int [20]类型，所以T对应的类型为int [20]；\n\n### **Notice**\n\n由于将引用作为函数参数时，数组参数传入函数时并不会转换为指针，所以对于下面的函数模板调用方式就会出错：\n\n```c++\ntemplate <typename T> void func(T &a, T &b);\nint a[20];\nint b[10];\nfunc(a, b);\n```\n\n在上述调用中，由于传入参数a,b的类型分别为int [20]和int [10]，导致编译器不能确定T的类型，从而报错。\n\n## 类模板\n\nC++中除了函数模板还支持类模板，类模板中定义的类型参数可以用在类的声明和实现中。类模板同样将数据的类型参数化，将类的实现与数据类型分离。声明类模板的方式与函数模板类似，同样是再类声明之前加上一个模板头。\n\n```c++\ntemplate <typename Name1, typename Name2>\nclass ClassName {\n    // Class body\n};\n```\n\n上面的代码仅仅是模板类的声明，对于在类外定义的成员函数，在定义时也需要加上模板头，类模板的成员函数定义格式如下：\n\n```c++\ntemplate <typename T1, typename T2, ...>\nReturnType ClassName<T1, T2, ...>::Func(Args) \n{\n\t// Function body    \n}\n```\n\n与函数模板不同的是，类模板在实例化时必须要显式的指明数据类型，编译器不能根据给定的数据推演出数据类型。\n\n类模板的实例化演示如下：\n\n```c++\nPoint<int, int> p1(10, 20);\nPoint<float, float> p2(10.1, 15.5);\n\nPoint<int, float> *p1 = new Point<int, float>(10, 15.5);\n```\n\n上面的代码实例化了3个Point模板类对象。\n\n## 模板的显式具体化\n\n\n\n## 模板的非类型参数\n\nC++模板中除了支持类型参数，还支持非类型的参数。例如下面的模板头：\n\n```c++\ntemplate<typename T, int N> void func(T (&arr)[N])\n```\n\n上面的模板函数定义中，在模板头中除了类型参数T， 还有一个非类型参数N，它有具体的类型int， 用来传递值。当调用一个函数模板或者一个类模板时，非类型参数会被用户提供，或者编译器推断出的值取代。\n\n模板中非类型参数的类型受到了严格限制，只能是一个整数，或者是一个指向对象或函数的指针（引用）。并且：\n\n1. 当非类型参数是一个整数时，传递给它的实参或者由编译器推导出的实参必须是一个常量表达式，而不能是变量。\n2. 当非类型参数是一个指针（引用）时， 绑定到该指针的实参必须具有静态生命周期，即实参必须是存在虚拟地址空间中的静态数据区，而不能是栈区或堆区的。\n\n## 模板的实例化\n\n模板（Templet）并不是真正的函数或类，它仅仅是编译器用来生成函数或类的一张“图纸”。模板不会占用内存，最终生成的函数或者类才会占用内存。由模板生成函数或类的过程叫做模板的实例化（Instantiate），相应地，针对某个类型生成的特定版本的函数或类叫做模板的一个实例（Instantiation）。模板也可以看做是编译器的一组指令，它命令编译器生成我们想要的代码。\n\n模板的实例化是按需进行的，用到哪个类型就生成针对哪个类型的函数或类，不会提前生成过多的代码。也就是说，编译器会根据传递给类型参数的实参（也可以是编译器自己推演出来的实参）来生成一个特定版本的函数或类，并且相同的类型只生成一次。实例化的过程也很简单，就是将所有的类型参数用实参代替。\n\n### **Notice**\n\n通过类模板创建对象时并不会实例化所有的成员函数，只有等到真正调用它们时才会被实例化；如果一个成员函数永远不会被调用，那它就永远不会被实例化。这说明类的实例化是延迟的、局部的，编译器并不着急生成所有的代码。\n\n由于类模板实例化的特殊性，模板的定义并不会直接将模板实例化，而只是提供一个实例化的图纸，因此在多文件编程中，不能像传统模块化那样将模板的声明和实现分别放到头文件和源文件中，这样做可能会导致链接器无法找到实例。而应该把模板的定义也一起放到头文件中，或者使用模板的显示实例化。\n\n通过代码明确地告诉编译器需要针对哪个类型进行实例化，这称为显式实例化。模板的显示实例化语法如下：\n\n```c++\n// 函数模板声明\ntemplate<typename T1, typename T2> void func(T1 &a, T2 &b);\n\n// 类模板声明\ntemplate<typename T1, typename T2> class Point {\npublic:\n    Point();\n};\n\n\n//显示实例化一个函数模板：template 返回值 函数名（类型1 a, 类型2 b, ...）;\ntemplate void func(double &a, double &b);\n//显示实例化一个类模板：template class 类名<类型1， 类型2, ...>\ntemplate class Point<int, double>;\n```\n\n显式实例化一个类模板时，会一次性实例化该类的所有成员，包括成员变量和成员函数。\n","source":"_posts/Cpp-Learning-Notes-Template.md","raw":"---\ntitle: C++ Learning Notes-Template\ndate: 2022-09-29 19:33:35\ncategories: Learning\ntags: \n  - c++\n  - programming basic\n---\n\n## C++泛型编程----模板\n\n泛型程序设计（generic programming）是一种算法在实现时不指定具体要操作的数据的类型的程序设计方法。所谓“泛型”，指的是算法只要实现一遍，就能适用于多种数据类型。泛型程序设计方法的优势在于能够减少重复代码的编写。\n\n为了实现泛型编程, C++中支持模板的概念.模板就是将数据类型也作为一个参数传递到具体的算法实现中(类型参数化),这样就实现了算法和数据类型的分离,即针对不同的数据类型,同一个模板都能正确处理.\n\n<!--more-->\n\n## 函数模板\n\n所谓函数模板，实际上是建立一个通用函数，它所用到的数据的类型（包括返回值类型、形参类型、局部变量类型）可以不具体指定，而是用一个虚拟的类型来代替（实际上是用一个标识符来占位），等发生函数调用时再根据传入的实参来逆推出真正的类型。这个通用函数就称为**函数模板（Function Template）**。\n\n### **函数模板的定义**\n\n```c++\ntemplate <typename TName1, typename TName2, ...> 返回值类型 函数名(形参列表) \n{\n\t// 函数体中可使用类型参数    \n}\n```\n\ntemplate 是定义函数模板的关键字,后面紧跟尖括号,尖括号内用于声明类型参数,其中typename也是关键字,可以声明多个类型参数.template <typename T>这样的结构被称为模板头,模板头中声明的类型参数可以用在后面函数定义或声明的任何位置.需要注意的是,typename 关键字可以被class关键字替代.\n\n### **函数模板的调用**\n\n在调用函数模板时，可以不用显示的指明具体类型参数，编译器会自动根据实参的类型做类型推断得到模板中的类型参数的类型，这个过程称为模板实参推断。对于模板实参推断，我们要注意函数调用时的类型转换问题。函数模板调用时，参数的类型转换相较于普通函数调用会收到更多限制，仅能进行[const]转换和数组或者函数指针转换，其他都不能应用于模板函数。例如有如下5个函数模板：\n\n```c++\ntemplate<typename T> void func1(T a, T b);\ntemplate<typename T> void func2(T *buff);\ntemplate<typename T> void func3(const T &stu);\ntemplate<typename T> void func4(T a);\ntemplate<typename T> void func5(T &a);\n```\n\n当按照如下代码进行调用时：\n\n```c++\nint name[20];\nStudent Stu1(\"XiaoMing\", 20, 96.5);\n\nfunc1(12.5, 30);   \t// Error\nfunc2(name);\t\t// T == int\nfunc3(stu1);\t\t// T == Student\nfunc4(name);\t\t// T == int*\nfunc5(name);\t\t// T == int[20]\n```\n\n对于func1的调用由于第一个参数为double类型，第二个为int类型，编译器不知道T应该为哪个类型，并且也不会做自动类型的转换，所以调用出错。\n\n对于func2的调用，name数组会转换为指针。所以T对应的类型为int。\n\n对于func3的调用，stu1参数会从非const转换为const，所以T对用的类型为Student类。\n\n对于func4的调用，name参数会从数组类型int [20]转换为指针int *, 所以T对应的类型为int *;\n\n对于func5的调用，name参数作为引用类型时不会从数组类型转换为指针，仍然为int [20]类型，所以T对应的类型为int [20]；\n\n### **Notice**\n\n由于将引用作为函数参数时，数组参数传入函数时并不会转换为指针，所以对于下面的函数模板调用方式就会出错：\n\n```c++\ntemplate <typename T> void func(T &a, T &b);\nint a[20];\nint b[10];\nfunc(a, b);\n```\n\n在上述调用中，由于传入参数a,b的类型分别为int [20]和int [10]，导致编译器不能确定T的类型，从而报错。\n\n## 类模板\n\nC++中除了函数模板还支持类模板，类模板中定义的类型参数可以用在类的声明和实现中。类模板同样将数据的类型参数化，将类的实现与数据类型分离。声明类模板的方式与函数模板类似，同样是再类声明之前加上一个模板头。\n\n```c++\ntemplate <typename Name1, typename Name2>\nclass ClassName {\n    // Class body\n};\n```\n\n上面的代码仅仅是模板类的声明，对于在类外定义的成员函数，在定义时也需要加上模板头，类模板的成员函数定义格式如下：\n\n```c++\ntemplate <typename T1, typename T2, ...>\nReturnType ClassName<T1, T2, ...>::Func(Args) \n{\n\t// Function body    \n}\n```\n\n与函数模板不同的是，类模板在实例化时必须要显式的指明数据类型，编译器不能根据给定的数据推演出数据类型。\n\n类模板的实例化演示如下：\n\n```c++\nPoint<int, int> p1(10, 20);\nPoint<float, float> p2(10.1, 15.5);\n\nPoint<int, float> *p1 = new Point<int, float>(10, 15.5);\n```\n\n上面的代码实例化了3个Point模板类对象。\n\n## 模板的显式具体化\n\n\n\n## 模板的非类型参数\n\nC++模板中除了支持类型参数，还支持非类型的参数。例如下面的模板头：\n\n```c++\ntemplate<typename T, int N> void func(T (&arr)[N])\n```\n\n上面的模板函数定义中，在模板头中除了类型参数T， 还有一个非类型参数N，它有具体的类型int， 用来传递值。当调用一个函数模板或者一个类模板时，非类型参数会被用户提供，或者编译器推断出的值取代。\n\n模板中非类型参数的类型受到了严格限制，只能是一个整数，或者是一个指向对象或函数的指针（引用）。并且：\n\n1. 当非类型参数是一个整数时，传递给它的实参或者由编译器推导出的实参必须是一个常量表达式，而不能是变量。\n2. 当非类型参数是一个指针（引用）时， 绑定到该指针的实参必须具有静态生命周期，即实参必须是存在虚拟地址空间中的静态数据区，而不能是栈区或堆区的。\n\n## 模板的实例化\n\n模板（Templet）并不是真正的函数或类，它仅仅是编译器用来生成函数或类的一张“图纸”。模板不会占用内存，最终生成的函数或者类才会占用内存。由模板生成函数或类的过程叫做模板的实例化（Instantiate），相应地，针对某个类型生成的特定版本的函数或类叫做模板的一个实例（Instantiation）。模板也可以看做是编译器的一组指令，它命令编译器生成我们想要的代码。\n\n模板的实例化是按需进行的，用到哪个类型就生成针对哪个类型的函数或类，不会提前生成过多的代码。也就是说，编译器会根据传递给类型参数的实参（也可以是编译器自己推演出来的实参）来生成一个特定版本的函数或类，并且相同的类型只生成一次。实例化的过程也很简单，就是将所有的类型参数用实参代替。\n\n### **Notice**\n\n通过类模板创建对象时并不会实例化所有的成员函数，只有等到真正调用它们时才会被实例化；如果一个成员函数永远不会被调用，那它就永远不会被实例化。这说明类的实例化是延迟的、局部的，编译器并不着急生成所有的代码。\n\n由于类模板实例化的特殊性，模板的定义并不会直接将模板实例化，而只是提供一个实例化的图纸，因此在多文件编程中，不能像传统模块化那样将模板的声明和实现分别放到头文件和源文件中，这样做可能会导致链接器无法找到实例。而应该把模板的定义也一起放到头文件中，或者使用模板的显示实例化。\n\n通过代码明确地告诉编译器需要针对哪个类型进行实例化，这称为显式实例化。模板的显示实例化语法如下：\n\n```c++\n// 函数模板声明\ntemplate<typename T1, typename T2> void func(T1 &a, T2 &b);\n\n// 类模板声明\ntemplate<typename T1, typename T2> class Point {\npublic:\n    Point();\n};\n\n\n//显示实例化一个函数模板：template 返回值 函数名（类型1 a, 类型2 b, ...）;\ntemplate void func(double &a, double &b);\n//显示实例化一个类模板：template class 类名<类型1， 类型2, ...>\ntemplate class Point<int, double>;\n```\n\n显式实例化一个类模板时，会一次性实例化该类的所有成员，包括成员变量和成员函数。\n","slug":"Cpp-Learning-Notes-Template","published":1,"updated":"2022-09-30T17:04:51.461Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl8oshjpp000116u78r0g9nvq","content":"<h2 id=\"C-泛型编程—-模板\"><a href=\"#C-泛型编程—-模板\" class=\"headerlink\" title=\"C++泛型编程—-模板\"></a>C++泛型编程—-模板</h2><p>泛型程序设计（generic programming）是一种算法在实现时不指定具体要操作的数据的类型的程序设计方法。所谓“泛型”，指的是算法只要实现一遍，就能适用于多种数据类型。泛型程序设计方法的优势在于能够减少重复代码的编写。</p>\n<p>为了实现泛型编程, C++中支持模板的概念.模板就是将数据类型也作为一个参数传递到具体的算法实现中(类型参数化),这样就实现了算法和数据类型的分离,即针对不同的数据类型,同一个模板都能正确处理.</p>\n<span id=\"more\"></span>\n\n<h2 id=\"函数模板\"><a href=\"#函数模板\" class=\"headerlink\" title=\"函数模板\"></a>函数模板</h2><p>所谓函数模板，实际上是建立一个通用函数，它所用到的数据的类型（包括返回值类型、形参类型、局部变量类型）可以不具体指定，而是用一个虚拟的类型来代替（实际上是用一个标识符来占位），等发生函数调用时再根据传入的实参来逆推出真正的类型。这个通用函数就称为<strong>函数模板（Function Template）</strong>。</p>\n<h3 id=\"函数模板的定义\"><a href=\"#函数模板的定义\" class=\"headerlink\" title=\"函数模板的定义\"></a><strong>函数模板的定义</strong></h3><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> TName1, <span class=\"keyword\">typename</span> TName2, ...&gt; 返回值类型 函数名(形参列表) </span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"comment\">// 函数体中可使用类型参数    </span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>template 是定义函数模板的关键字,后面紧跟尖括号,尖括号内用于声明类型参数,其中typename也是关键字,可以声明多个类型参数.template <typename T>这样的结构被称为模板头,模板头中声明的类型参数可以用在后面函数定义或声明的任何位置.需要注意的是,typename 关键字可以被class关键字替代.</p>\n<h3 id=\"函数模板的调用\"><a href=\"#函数模板的调用\" class=\"headerlink\" title=\"函数模板的调用\"></a><strong>函数模板的调用</strong></h3><p>在调用函数模板时，可以不用显示的指明具体类型参数，编译器会自动根据实参的类型做类型推断得到模板中的类型参数的类型，这个过程称为模板实参推断。对于模板实参推断，我们要注意函数调用时的类型转换问题。函数模板调用时，参数的类型转换相较于普通函数调用会收到更多限制，仅能进行[const]转换和数组或者函数指针转换，其他都不能应用于模板函数。例如有如下5个函数模板：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">template</span>&lt;<span class=\"keyword\">typename</span> T&gt; <span class=\"type\">void</span> <span class=\"title\">func1</span><span class=\"params\">(T a, T b)</span></span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">template</span>&lt;<span class=\"keyword\">typename</span> T&gt; <span class=\"type\">void</span> <span class=\"title\">func2</span><span class=\"params\">(T *buff)</span></span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">template</span>&lt;<span class=\"keyword\">typename</span> T&gt; <span class=\"type\">void</span> <span class=\"title\">func3</span><span class=\"params\">(<span class=\"type\">const</span> T &amp;stu)</span></span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">template</span>&lt;<span class=\"keyword\">typename</span> T&gt; <span class=\"type\">void</span> <span class=\"title\">func4</span><span class=\"params\">(T a)</span></span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">template</span>&lt;<span class=\"keyword\">typename</span> T&gt; <span class=\"type\">void</span> <span class=\"title\">func5</span><span class=\"params\">(T &amp;a)</span></span>;</span><br></pre></td></tr></table></figure>\n\n<p>当按照如下代码进行调用时：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> name[<span class=\"number\">20</span>];</span><br><span class=\"line\"><span class=\"function\">Student <span class=\"title\">Stu1</span><span class=\"params\">(<span class=\"string\">&quot;XiaoMing&quot;</span>, <span class=\"number\">20</span>, <span class=\"number\">96.5</span>)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">func1</span>(<span class=\"number\">12.5</span>, <span class=\"number\">30</span>);   \t<span class=\"comment\">// Error</span></span><br><span class=\"line\"><span class=\"built_in\">func2</span>(name);\t\t<span class=\"comment\">// T == int</span></span><br><span class=\"line\"><span class=\"built_in\">func3</span>(stu1);\t\t<span class=\"comment\">// T == Student</span></span><br><span class=\"line\"><span class=\"built_in\">func4</span>(name);\t\t<span class=\"comment\">// T == int*</span></span><br><span class=\"line\"><span class=\"built_in\">func5</span>(name);\t\t<span class=\"comment\">// T == int[20]</span></span><br></pre></td></tr></table></figure>\n\n<p>对于func1的调用由于第一个参数为double类型，第二个为int类型，编译器不知道T应该为哪个类型，并且也不会做自动类型的转换，所以调用出错。</p>\n<p>对于func2的调用，name数组会转换为指针。所以T对应的类型为int。</p>\n<p>对于func3的调用，stu1参数会从非const转换为const，所以T对用的类型为Student类。</p>\n<p>对于func4的调用，name参数会从数组类型int [20]转换为指针int *, 所以T对应的类型为int *;</p>\n<p>对于func5的调用，name参数作为引用类型时不会从数组类型转换为指针，仍然为int [20]类型，所以T对应的类型为int [20]；</p>\n<h3 id=\"Notice\"><a href=\"#Notice\" class=\"headerlink\" title=\"Notice\"></a><strong>Notice</strong></h3><p>由于将引用作为函数参数时，数组参数传入函数时并不会转换为指针，所以对于下面的函数模板调用方式就会出错：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> T&gt; <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">func</span><span class=\"params\">(T &amp;a, T &amp;b)</span></span>;</span><br><span class=\"line\"><span class=\"type\">int</span> a[<span class=\"number\">20</span>];</span><br><span class=\"line\"><span class=\"type\">int</span> b[<span class=\"number\">10</span>];</span><br><span class=\"line\"><span class=\"built_in\">func</span>(a, b);</span><br></pre></td></tr></table></figure>\n\n<p>在上述调用中，由于传入参数a,b的类型分别为int [20]和int [10]，导致编译器不能确定T的类型，从而报错。</p>\n<h2 id=\"类模板\"><a href=\"#类模板\" class=\"headerlink\" title=\"类模板\"></a>类模板</h2><p>C++中除了函数模板还支持类模板，类模板中定义的类型参数可以用在类的声明和实现中。类模板同样将数据的类型参数化，将类的实现与数据类型分离。声明类模板的方式与函数模板类似，同样是再类声明之前加上一个模板头。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> Name1, <span class=\"keyword\">typename</span> Name2&gt;</span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">ClassName</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// Class body</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>上面的代码仅仅是模板类的声明，对于在类外定义的成员函数，在定义时也需要加上模板头，类模板的成员函数定义格式如下：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> T1, <span class=\"keyword\">typename</span> T2, ...&gt;</span><br><span class=\"line\">ReturnType ClassName&lt;T1, T2, ...&gt;::<span class=\"built_in\">Func</span>(Args) </span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"comment\">// Function body    </span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>与函数模板不同的是，类模板在实例化时必须要显式的指明数据类型，编译器不能根据给定的数据推演出数据类型。</p>\n<p>类模板的实例化演示如下：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">Point&lt;<span class=\"type\">int</span>, <span class=\"type\">int</span>&gt; <span class=\"title\">p1</span><span class=\"params\">(<span class=\"number\">10</span>, <span class=\"number\">20</span>)</span></span>;</span><br><span class=\"line\"><span class=\"function\">Point&lt;<span class=\"type\">float</span>, <span class=\"type\">float</span>&gt; <span class=\"title\">p2</span><span class=\"params\">(<span class=\"number\">10.1</span>, <span class=\"number\">15.5</span>)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">Point&lt;<span class=\"type\">int</span>, <span class=\"type\">float</span>&gt; *p1 = <span class=\"keyword\">new</span> <span class=\"built_in\">Point</span>&lt;<span class=\"type\">int</span>, <span class=\"type\">float</span>&gt;(<span class=\"number\">10</span>, <span class=\"number\">15.5</span>);</span><br></pre></td></tr></table></figure>\n\n<p>上面的代码实例化了3个Point模板类对象。</p>\n<h2 id=\"模板的显式具体化\"><a href=\"#模板的显式具体化\" class=\"headerlink\" title=\"模板的显式具体化\"></a>模板的显式具体化</h2><h2 id=\"模板的非类型参数\"><a href=\"#模板的非类型参数\" class=\"headerlink\" title=\"模板的非类型参数\"></a>模板的非类型参数</h2><p>C++模板中除了支持类型参数，还支持非类型的参数。例如下面的模板头：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">template</span>&lt;<span class=\"keyword\">typename</span> T, <span class=\"type\">int</span> N&gt; <span class=\"type\">void</span> <span class=\"title\">func</span><span class=\"params\">(T (&amp;arr)[N])</span></span></span><br></pre></td></tr></table></figure>\n\n<p>上面的模板函数定义中，在模板头中除了类型参数T， 还有一个非类型参数N，它有具体的类型int， 用来传递值。当调用一个函数模板或者一个类模板时，非类型参数会被用户提供，或者编译器推断出的值取代。</p>\n<p>模板中非类型参数的类型受到了严格限制，只能是一个整数，或者是一个指向对象或函数的指针（引用）。并且：</p>\n<ol>\n<li>当非类型参数是一个整数时，传递给它的实参或者由编译器推导出的实参必须是一个常量表达式，而不能是变量。</li>\n<li>当非类型参数是一个指针（引用）时， 绑定到该指针的实参必须具有静态生命周期，即实参必须是存在虚拟地址空间中的静态数据区，而不能是栈区或堆区的。</li>\n</ol>\n<h2 id=\"模板的实例化\"><a href=\"#模板的实例化\" class=\"headerlink\" title=\"模板的实例化\"></a>模板的实例化</h2><p>模板（Templet）并不是真正的函数或类，它仅仅是编译器用来生成函数或类的一张“图纸”。模板不会占用内存，最终生成的函数或者类才会占用内存。由模板生成函数或类的过程叫做模板的实例化（Instantiate），相应地，针对某个类型生成的特定版本的函数或类叫做模板的一个实例（Instantiation）。模板也可以看做是编译器的一组指令，它命令编译器生成我们想要的代码。</p>\n<p>模板的实例化是按需进行的，用到哪个类型就生成针对哪个类型的函数或类，不会提前生成过多的代码。也就是说，编译器会根据传递给类型参数的实参（也可以是编译器自己推演出来的实参）来生成一个特定版本的函数或类，并且相同的类型只生成一次。实例化的过程也很简单，就是将所有的类型参数用实参代替。</p>\n<h3 id=\"Notice-1\"><a href=\"#Notice-1\" class=\"headerlink\" title=\"Notice\"></a><strong>Notice</strong></h3><p>通过类模板创建对象时并不会实例化所有的成员函数，只有等到真正调用它们时才会被实例化；如果一个成员函数永远不会被调用，那它就永远不会被实例化。这说明类的实例化是延迟的、局部的，编译器并不着急生成所有的代码。</p>\n<p>由于类模板实例化的特殊性，模板的定义并不会直接将模板实例化，而只是提供一个实例化的图纸，因此在多文件编程中，不能像传统模块化那样将模板的声明和实现分别放到头文件和源文件中，这样做可能会导致链接器无法找到实例。而应该把模板的定义也一起放到头文件中，或者使用模板的显示实例化。</p>\n<p>通过代码明确地告诉编译器需要针对哪个类型进行实例化，这称为显式实例化。模板的显示实例化语法如下：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 函数模板声明</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">template</span>&lt;<span class=\"keyword\">typename</span> T1, <span class=\"keyword\">typename</span> T2&gt; <span class=\"type\">void</span> <span class=\"title\">func</span><span class=\"params\">(T1 &amp;a, T2 &amp;b)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 类模板声明</span></span><br><span class=\"line\"><span class=\"keyword\">template</span>&lt;<span class=\"keyword\">typename</span> T1, <span class=\"keyword\">typename</span> T2&gt; <span class=\"keyword\">class</span> <span class=\"title class_\">Point</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"built_in\">Point</span>();</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//显示实例化一个函数模板：template 返回值 函数名（类型1 a, 类型2 b, ...）;</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">template</span> <span class=\"type\">void</span> <span class=\"title\">func</span><span class=\"params\">(<span class=\"type\">double</span> &amp;a, <span class=\"type\">double</span> &amp;b)</span></span>;</span><br><span class=\"line\"><span class=\"comment\">//显示实例化一个类模板：template class 类名&lt;类型1， 类型2, ...&gt;</span></span><br><span class=\"line\"><span class=\"keyword\">template</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Point</span>&lt;<span class=\"type\">int</span>, <span class=\"type\">double</span>&gt;;</span><br></pre></td></tr></table></figure>\n\n<p>显式实例化一个类模板时，会一次性实例化该类的所有成员，包括成员变量和成员函数。</p>\n","site":{"data":{}},"excerpt":"<h2 id=\"C-泛型编程—-模板\"><a href=\"#C-泛型编程—-模板\" class=\"headerlink\" title=\"C++泛型编程—-模板\"></a>C++泛型编程—-模板</h2><p>泛型程序设计（generic programming）是一种算法在实现时不指定具体要操作的数据的类型的程序设计方法。所谓“泛型”，指的是算法只要实现一遍，就能适用于多种数据类型。泛型程序设计方法的优势在于能够减少重复代码的编写。</p>\n<p>为了实现泛型编程, C++中支持模板的概念.模板就是将数据类型也作为一个参数传递到具体的算法实现中(类型参数化),这样就实现了算法和数据类型的分离,即针对不同的数据类型,同一个模板都能正确处理.</p>","more":"<h2 id=\"函数模板\"><a href=\"#函数模板\" class=\"headerlink\" title=\"函数模板\"></a>函数模板</h2><p>所谓函数模板，实际上是建立一个通用函数，它所用到的数据的类型（包括返回值类型、形参类型、局部变量类型）可以不具体指定，而是用一个虚拟的类型来代替（实际上是用一个标识符来占位），等发生函数调用时再根据传入的实参来逆推出真正的类型。这个通用函数就称为<strong>函数模板（Function Template）</strong>。</p>\n<h3 id=\"函数模板的定义\"><a href=\"#函数模板的定义\" class=\"headerlink\" title=\"函数模板的定义\"></a><strong>函数模板的定义</strong></h3><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> TName1, <span class=\"keyword\">typename</span> TName2, ...&gt; 返回值类型 函数名(形参列表) </span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"comment\">// 函数体中可使用类型参数    </span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>template 是定义函数模板的关键字,后面紧跟尖括号,尖括号内用于声明类型参数,其中typename也是关键字,可以声明多个类型参数.template <typename T>这样的结构被称为模板头,模板头中声明的类型参数可以用在后面函数定义或声明的任何位置.需要注意的是,typename 关键字可以被class关键字替代.</p>\n<h3 id=\"函数模板的调用\"><a href=\"#函数模板的调用\" class=\"headerlink\" title=\"函数模板的调用\"></a><strong>函数模板的调用</strong></h3><p>在调用函数模板时，可以不用显示的指明具体类型参数，编译器会自动根据实参的类型做类型推断得到模板中的类型参数的类型，这个过程称为模板实参推断。对于模板实参推断，我们要注意函数调用时的类型转换问题。函数模板调用时，参数的类型转换相较于普通函数调用会收到更多限制，仅能进行[const]转换和数组或者函数指针转换，其他都不能应用于模板函数。例如有如下5个函数模板：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">template</span>&lt;<span class=\"keyword\">typename</span> T&gt; <span class=\"type\">void</span> <span class=\"title\">func1</span><span class=\"params\">(T a, T b)</span></span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">template</span>&lt;<span class=\"keyword\">typename</span> T&gt; <span class=\"type\">void</span> <span class=\"title\">func2</span><span class=\"params\">(T *buff)</span></span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">template</span>&lt;<span class=\"keyword\">typename</span> T&gt; <span class=\"type\">void</span> <span class=\"title\">func3</span><span class=\"params\">(<span class=\"type\">const</span> T &amp;stu)</span></span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">template</span>&lt;<span class=\"keyword\">typename</span> T&gt; <span class=\"type\">void</span> <span class=\"title\">func4</span><span class=\"params\">(T a)</span></span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">template</span>&lt;<span class=\"keyword\">typename</span> T&gt; <span class=\"type\">void</span> <span class=\"title\">func5</span><span class=\"params\">(T &amp;a)</span></span>;</span><br></pre></td></tr></table></figure>\n\n<p>当按照如下代码进行调用时：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> name[<span class=\"number\">20</span>];</span><br><span class=\"line\"><span class=\"function\">Student <span class=\"title\">Stu1</span><span class=\"params\">(<span class=\"string\">&quot;XiaoMing&quot;</span>, <span class=\"number\">20</span>, <span class=\"number\">96.5</span>)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">func1</span>(<span class=\"number\">12.5</span>, <span class=\"number\">30</span>);   \t<span class=\"comment\">// Error</span></span><br><span class=\"line\"><span class=\"built_in\">func2</span>(name);\t\t<span class=\"comment\">// T == int</span></span><br><span class=\"line\"><span class=\"built_in\">func3</span>(stu1);\t\t<span class=\"comment\">// T == Student</span></span><br><span class=\"line\"><span class=\"built_in\">func4</span>(name);\t\t<span class=\"comment\">// T == int*</span></span><br><span class=\"line\"><span class=\"built_in\">func5</span>(name);\t\t<span class=\"comment\">// T == int[20]</span></span><br></pre></td></tr></table></figure>\n\n<p>对于func1的调用由于第一个参数为double类型，第二个为int类型，编译器不知道T应该为哪个类型，并且也不会做自动类型的转换，所以调用出错。</p>\n<p>对于func2的调用，name数组会转换为指针。所以T对应的类型为int。</p>\n<p>对于func3的调用，stu1参数会从非const转换为const，所以T对用的类型为Student类。</p>\n<p>对于func4的调用，name参数会从数组类型int [20]转换为指针int *, 所以T对应的类型为int *;</p>\n<p>对于func5的调用，name参数作为引用类型时不会从数组类型转换为指针，仍然为int [20]类型，所以T对应的类型为int [20]；</p>\n<h3 id=\"Notice\"><a href=\"#Notice\" class=\"headerlink\" title=\"Notice\"></a><strong>Notice</strong></h3><p>由于将引用作为函数参数时，数组参数传入函数时并不会转换为指针，所以对于下面的函数模板调用方式就会出错：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> T&gt; <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">func</span><span class=\"params\">(T &amp;a, T &amp;b)</span></span>;</span><br><span class=\"line\"><span class=\"type\">int</span> a[<span class=\"number\">20</span>];</span><br><span class=\"line\"><span class=\"type\">int</span> b[<span class=\"number\">10</span>];</span><br><span class=\"line\"><span class=\"built_in\">func</span>(a, b);</span><br></pre></td></tr></table></figure>\n\n<p>在上述调用中，由于传入参数a,b的类型分别为int [20]和int [10]，导致编译器不能确定T的类型，从而报错。</p>\n<h2 id=\"类模板\"><a href=\"#类模板\" class=\"headerlink\" title=\"类模板\"></a>类模板</h2><p>C++中除了函数模板还支持类模板，类模板中定义的类型参数可以用在类的声明和实现中。类模板同样将数据的类型参数化，将类的实现与数据类型分离。声明类模板的方式与函数模板类似，同样是再类声明之前加上一个模板头。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> Name1, <span class=\"keyword\">typename</span> Name2&gt;</span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">ClassName</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// Class body</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>上面的代码仅仅是模板类的声明，对于在类外定义的成员函数，在定义时也需要加上模板头，类模板的成员函数定义格式如下：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> T1, <span class=\"keyword\">typename</span> T2, ...&gt;</span><br><span class=\"line\">ReturnType ClassName&lt;T1, T2, ...&gt;::<span class=\"built_in\">Func</span>(Args) </span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"comment\">// Function body    </span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>与函数模板不同的是，类模板在实例化时必须要显式的指明数据类型，编译器不能根据给定的数据推演出数据类型。</p>\n<p>类模板的实例化演示如下：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">Point&lt;<span class=\"type\">int</span>, <span class=\"type\">int</span>&gt; <span class=\"title\">p1</span><span class=\"params\">(<span class=\"number\">10</span>, <span class=\"number\">20</span>)</span></span>;</span><br><span class=\"line\"><span class=\"function\">Point&lt;<span class=\"type\">float</span>, <span class=\"type\">float</span>&gt; <span class=\"title\">p2</span><span class=\"params\">(<span class=\"number\">10.1</span>, <span class=\"number\">15.5</span>)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">Point&lt;<span class=\"type\">int</span>, <span class=\"type\">float</span>&gt; *p1 = <span class=\"keyword\">new</span> <span class=\"built_in\">Point</span>&lt;<span class=\"type\">int</span>, <span class=\"type\">float</span>&gt;(<span class=\"number\">10</span>, <span class=\"number\">15.5</span>);</span><br></pre></td></tr></table></figure>\n\n<p>上面的代码实例化了3个Point模板类对象。</p>\n<h2 id=\"模板的显式具体化\"><a href=\"#模板的显式具体化\" class=\"headerlink\" title=\"模板的显式具体化\"></a>模板的显式具体化</h2><h2 id=\"模板的非类型参数\"><a href=\"#模板的非类型参数\" class=\"headerlink\" title=\"模板的非类型参数\"></a>模板的非类型参数</h2><p>C++模板中除了支持类型参数，还支持非类型的参数。例如下面的模板头：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">template</span>&lt;<span class=\"keyword\">typename</span> T, <span class=\"type\">int</span> N&gt; <span class=\"type\">void</span> <span class=\"title\">func</span><span class=\"params\">(T (&amp;arr)[N])</span></span></span><br></pre></td></tr></table></figure>\n\n<p>上面的模板函数定义中，在模板头中除了类型参数T， 还有一个非类型参数N，它有具体的类型int， 用来传递值。当调用一个函数模板或者一个类模板时，非类型参数会被用户提供，或者编译器推断出的值取代。</p>\n<p>模板中非类型参数的类型受到了严格限制，只能是一个整数，或者是一个指向对象或函数的指针（引用）。并且：</p>\n<ol>\n<li>当非类型参数是一个整数时，传递给它的实参或者由编译器推导出的实参必须是一个常量表达式，而不能是变量。</li>\n<li>当非类型参数是一个指针（引用）时， 绑定到该指针的实参必须具有静态生命周期，即实参必须是存在虚拟地址空间中的静态数据区，而不能是栈区或堆区的。</li>\n</ol>\n<h2 id=\"模板的实例化\"><a href=\"#模板的实例化\" class=\"headerlink\" title=\"模板的实例化\"></a>模板的实例化</h2><p>模板（Templet）并不是真正的函数或类，它仅仅是编译器用来生成函数或类的一张“图纸”。模板不会占用内存，最终生成的函数或者类才会占用内存。由模板生成函数或类的过程叫做模板的实例化（Instantiate），相应地，针对某个类型生成的特定版本的函数或类叫做模板的一个实例（Instantiation）。模板也可以看做是编译器的一组指令，它命令编译器生成我们想要的代码。</p>\n<p>模板的实例化是按需进行的，用到哪个类型就生成针对哪个类型的函数或类，不会提前生成过多的代码。也就是说，编译器会根据传递给类型参数的实参（也可以是编译器自己推演出来的实参）来生成一个特定版本的函数或类，并且相同的类型只生成一次。实例化的过程也很简单，就是将所有的类型参数用实参代替。</p>\n<h3 id=\"Notice-1\"><a href=\"#Notice-1\" class=\"headerlink\" title=\"Notice\"></a><strong>Notice</strong></h3><p>通过类模板创建对象时并不会实例化所有的成员函数，只有等到真正调用它们时才会被实例化；如果一个成员函数永远不会被调用，那它就永远不会被实例化。这说明类的实例化是延迟的、局部的，编译器并不着急生成所有的代码。</p>\n<p>由于类模板实例化的特殊性，模板的定义并不会直接将模板实例化，而只是提供一个实例化的图纸，因此在多文件编程中，不能像传统模块化那样将模板的声明和实现分别放到头文件和源文件中，这样做可能会导致链接器无法找到实例。而应该把模板的定义也一起放到头文件中，或者使用模板的显示实例化。</p>\n<p>通过代码明确地告诉编译器需要针对哪个类型进行实例化，这称为显式实例化。模板的显示实例化语法如下：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 函数模板声明</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">template</span>&lt;<span class=\"keyword\">typename</span> T1, <span class=\"keyword\">typename</span> T2&gt; <span class=\"type\">void</span> <span class=\"title\">func</span><span class=\"params\">(T1 &amp;a, T2 &amp;b)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 类模板声明</span></span><br><span class=\"line\"><span class=\"keyword\">template</span>&lt;<span class=\"keyword\">typename</span> T1, <span class=\"keyword\">typename</span> T2&gt; <span class=\"keyword\">class</span> <span class=\"title class_\">Point</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"built_in\">Point</span>();</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//显示实例化一个函数模板：template 返回值 函数名（类型1 a, 类型2 b, ...）;</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">template</span> <span class=\"type\">void</span> <span class=\"title\">func</span><span class=\"params\">(<span class=\"type\">double</span> &amp;a, <span class=\"type\">double</span> &amp;b)</span></span>;</span><br><span class=\"line\"><span class=\"comment\">//显示实例化一个类模板：template class 类名&lt;类型1， 类型2, ...&gt;</span></span><br><span class=\"line\"><span class=\"keyword\">template</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Point</span>&lt;<span class=\"type\">int</span>, <span class=\"type\">double</span>&gt;;</span><br></pre></td></tr></table></figure>\n\n<p>显式实例化一个类模板时，会一次性实例化该类的所有成员，包括成员变量和成员函数。</p>"},{"title":"Hello World","post":false,"_content":"Welcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/one-command-deployment.html)\n","source":"_posts/hello-world.md","raw":"---\ntitle: Hello World\npost: false\n---\nWelcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/one-command-deployment.html)\n","slug":"hello-world","published":1,"date":"2022-09-30T17:37:43.996Z","updated":"2022-09-30T17:04:51.461Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl8oshjps000316u7dnoo4fg6","content":"<p>Welcome to <a href=\"https://hexo.io/\">Hexo</a>! This is your very first post. Check <a href=\"https://hexo.io/docs/\">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href=\"https://hexo.io/docs/troubleshooting.html\">troubleshooting</a> or you can ask me on <a href=\"https://github.com/hexojs/hexo/issues\">GitHub</a>.</p>\n<h2 id=\"Quick-Start\"><a href=\"#Quick-Start\" class=\"headerlink\" title=\"Quick Start\"></a>Quick Start</h2><h3 id=\"Create-a-new-post\"><a href=\"#Create-a-new-post\" class=\"headerlink\" title=\"Create a new post\"></a>Create a new post</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo new <span class=\"string\">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/writing.html\">Writing</a></p>\n<h3 id=\"Run-server\"><a href=\"#Run-server\" class=\"headerlink\" title=\"Run server\"></a>Run server</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo server</span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/server.html\">Server</a></p>\n<h3 id=\"Generate-static-files\"><a href=\"#Generate-static-files\" class=\"headerlink\" title=\"Generate static files\"></a>Generate static files</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo generate</span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/generating.html\">Generating</a></p>\n<h3 id=\"Deploy-to-remote-sites\"><a href=\"#Deploy-to-remote-sites\" class=\"headerlink\" title=\"Deploy to remote sites\"></a>Deploy to remote sites</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo deploy</span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/one-command-deployment.html\">Deployment</a></p>\n","site":{"data":{}},"excerpt":"","more":"<p>Welcome to <a href=\"https://hexo.io/\">Hexo</a>! This is your very first post. Check <a href=\"https://hexo.io/docs/\">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href=\"https://hexo.io/docs/troubleshooting.html\">troubleshooting</a> or you can ask me on <a href=\"https://github.com/hexojs/hexo/issues\">GitHub</a>.</p>\n<h2 id=\"Quick-Start\"><a href=\"#Quick-Start\" class=\"headerlink\" title=\"Quick Start\"></a>Quick Start</h2><h3 id=\"Create-a-new-post\"><a href=\"#Create-a-new-post\" class=\"headerlink\" title=\"Create a new post\"></a>Create a new post</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo new <span class=\"string\">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/writing.html\">Writing</a></p>\n<h3 id=\"Run-server\"><a href=\"#Run-server\" class=\"headerlink\" title=\"Run server\"></a>Run server</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo server</span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/server.html\">Server</a></p>\n<h3 id=\"Generate-static-files\"><a href=\"#Generate-static-files\" class=\"headerlink\" title=\"Generate static files\"></a>Generate static files</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo generate</span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/generating.html\">Generating</a></p>\n<h3 id=\"Deploy-to-remote-sites\"><a href=\"#Deploy-to-remote-sites\" class=\"headerlink\" title=\"Deploy to remote sites\"></a>Deploy to remote sites</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo deploy</span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/one-command-deployment.html\">Deployment</a></p>\n"},{"title":"Makefile Learning Notes","date":"2022-09-29T11:11:06.000Z","_content":"\n## 基本语法与规则\n\nMakefile 描述的是文件编译的规则，一条规则主要由两部分组成，依赖关系和命令：\n\n```makefile\ntargets : prerequisites\n\tcommand\n```\n\n- targets: 规则的目标，可以是.o，可以是可执行文件，还可以是一个标签\n- prerequisites: 生成目标的依赖文件，可以是多个或者没有\n- command: make时需要执行的命令，可以是任意的shell命令，可以有多条命令，每条命令占一行。\n\n<!--more-->\n\nMakefile中主要包含的内容：\n\n1. 显示规则：显式说明如何生成一个目标文件\n2. 隐晦规则：make命令支持自动推导功能\n3. 变量的定义：Makefile中可以定义一系列变量，其用法与shell中的变量类似。\n4. 文件指示：可以在一个makefile中引用另一个makefile，类似c中的include。可以根据某些情况制定makefile中的有效部分，类似c中的条件编译。还可以自定义多行的命令。\n5. 注释：与shell相同，用#号注释。\n\nmake的执行过程：\n\n在shell中执行make之后，会自动搜索Makefile文件，并且将脚本中的第一条规则\n\n定义的目标作为最终目标，然后检查目标的依赖，这时有三种情况：\n\n1. 如果依赖的中间文件不存在，则会根据规则生成中间文件\n2. 如果依赖的中间文件存在，并且没有它所依赖的生成文件新，则会重新生成这个中间文件。\n3. 如果依赖的中间文件存在，并且它所依赖的生成文件也没有更新，则不会重新生成。\n\n## Makefile 中的通配符\n\nMakefile 支持shell中的通配符，如下：\n\n| 通配符 | 说明                   |\n| ------ | ---------------------- |\n| *      | 匹配0个或多个任意字符  |\n| ?      | 匹配任意一个字符       |\n| []     | 匹配方括号中制定的字符 |\n\n通配符在引用变量时的使用，在写依赖规则时，如果直接使用有通配符的变量，会出现错误。如\n\n``` makefile\nobj = *.c\ntest : $(obj)\n\tgcc -o $@ $^\n```\n\n当按如上规则make时，会报错找不到*.c。这是因为变量引用中的通配符并不会被展开。而如果想在引用的变量中使用通配符，则需要借助wildcard函数，这个函数会在引用变量时进行通配符的展开，如：\n\n``` makefile\nobj = $(wildcard *.c)\ntest : $(obj)\n\tgcc -o $@ $^\n```\n\nMakefile 中还支持 % 通配符，也是匹配任意个字符，\n\n``` makefile\ntest : test1.o test2.o\n\tgcc -o $@ $^\n%.o : %.c\n\tgcc -o $@ $^\n```\n\n%.o会把所有.o文件组合成一个列表，每次从列表中取出一个文件，然后找到文件中和%名称相同的.c文件，然后执行下面的文件，直至列表中的文件取完。这个属于Makefile中静态模规则：规则存在多个目标，规则存在多个目标，并且不同的目标可以根据目标文件的名字自动构造出依赖文件。\n\n## Makefile中的变量\n\n### 变量的定义\n\n`变量名称 = 值列表`\n\n变量名称可以由字母数字和下划线构成，等号左右的空格没有要求，值列表可以是0项，也可以是多项，中间用空格分隔。\n\n``` makefile\nOBJ = a.o b.o c.o\ntest : $(OBJ)\n\tgcc -o test $(OBJ)\n```\n\n### 变量的基本赋值\n\n- 简单赋值(:=)   编程语句中的常规赋值方式，只对当前语句的变量有效\n- 递归赋值(=)    所有目标变量相关的变量都会受影响，赋值语句可能影响多个变量\n- 条件赋值(?=)   如果变量未定义，则使用符号中的值定义变量，\n- 追加赋值(+=)   在变量的值列表后面追加一项新的值\n\n``` makefile\nx = abc\ny = $(x)d\nx := efg\t# 简单赋值 x=efg, y=abcd\nx = efg\t\t# 递归赋值 x=efg, y=efgd\nx ?= efg\t# 条件赋值 x=abc, y=abcd\nx += efg\t# 追加赋值 x=abc efg, y=abcd\n\n```\n\n### 自动化变量\n\n| 自动化变量 | 说明                                                         |\n| :--------: | ------------------------------------------------------------ |\n|     $@     | 表示规则的目标文件名。如果目标是一个文档文件（Linux 中，一般成 .a 文件为文档文件，也成为静态的库文件）， 那么它代表这个文档的文件名。在多目标模式规则中，它代表的是触发规则被执行的文件名。 |\n|     $%     | 当目标文件是一个静态库文件时，代表静态库的一个成员名。       |\n|     $<     | 规则的第一个依赖的文件名。如果是一个目标文件使用隐含的规则来重建，则它代表由隐含规则加入的第一个依赖文件。 |\n|     $?     | 所有比目标文件更新的依赖文件列表，空格分隔。如果目标文件时静态库文件，代表的是库文件（.o 文件）。 |\n|     $^     | 代表的是所有依赖文件列表，使用空格分隔。如果目标是静态库文件，它所代表的只能是所有的库成员（.o 文件）名。 一个文件可重复的出现在目标的依赖中，变量$^ 只记录它的第一次引用的情况。就是说会去掉重复的依赖文件。 |\n|     $+     | 类似“$^”，但是它保留了依赖文件中重复出现的文件。主要用在程序链接时库的交叉引用场合。 |\n|     $*     | 在模式规则和静态模式规则中，代表“茎”。“茎”是目标模式中“%”所代表的部分（当文件名中存在目录时， “茎”也包含目录部分）。 |\n\n## Makefile 目标文件搜索路径\n\n有两种方式可以制定Makefile脚本搜索目标文件的目录路径：一般搜索`VPATH` 和选择搜索`vpath`.\n\nVPATH和vpath的区别在于，VPATH是一个变量，而且是环境变量，使用时需要指定文件的路径；vpath是关键字，按照指定的模式搜索，搜索时不仅要加上路径，还要加上限值条件。\n\n### VPATH\n\n在Makefile中按如下形式使用VPATH指定搜索路径：\n\n``` makefile\nVPATH := src\n```\n\n当要指定多个路径时，不同的路径之间用空格或者冒号分隔。\n\n``` makefile\nVPAHT := path1:path2\n```\n\n ### vpath\n\nvpath按照给定模式在指定目录中搜索，使用方法如下：\n\n```makefile\n1. vpath PATTERN DIRECTORIES\n2. vpath PATTERN\n3. vpath\n```\n\n用法二的意思是清除符合模式 的搜索目录，用法3 单独使用vpath是清楚所有已设置的文件搜索路径。\n\n### 应用\n\n假设现在有一个工程，包含两个目录，src目录下包含main.c, module1.c, module2.c源文件，inc目录下包含module1.h, module2.h头文件。通过如下方式先声明文件搜索路径。\n\n``` makefile\nvpath %.c \tsrc\nvpath %.h\tinc\t\t## 或者使用 VPATH = src inc\nmain : main.o module1.o module2.o\n\tgcc -o $@ $<\nmain.o : main.c\n\tgcc -o $@ $^\nmodule1.o : module1.c module1.h\n\tgcc -o $@ $<\nmodule2.o : module2.c module2.h\n\tgcc -o $@ $<\n```\n\n## Makefile 隐含规则\n\n\n\n## Makefile 条件判断\n\n在实际工程中，经常会遇到要根据某个条件执行不同的编译操作的情况。这是就需要在Makefile中能够实现分条件执行语句的功能。Makefile中提供以下条件判断关键字：\n\n| 关键字 | 说明             |      |\n| ------ | ---------------- | ---- |\n| ifeq   | 判断参数是否相等 |      |\n| ifneq  | 判断参数是否不等 |      |\n| ifdef  | 判断是否有值     |      |\n| ifndef | 判断是否没有值   |      |\n\n### ifeq 和 ifneq\n\n使用语法\n\n``` makefile\nifeq (ARG1, arg2)\n# ifeq \"ARG1\" \"ARG2\"\n# ifeq 'ARG1' 'ARG2'\n\txxx\nelse\n\txxx\nendif\n```\n\n举例\n\n``` makefile\ngcc_libs = -lgnu\ndefault_libs = \nifeq ($(CC), gcc)\n\tlibs = $(gcc_libs)\nelse\n\tlibs = $(default_libs)\nendif\nfoo : $(objects)\n\t$(CC) -o foo $(objects) $(libs)\n```\n\n### ifdef 和 ifndef\n\n使用语法：\n\n``` makefile\nifdef VARIABLE_NAME\n```\n\n## Makefile 伪目标\n\n伪目标的含义是它并不会创建目标文件，但是会去执行这个目标下面的命令。使用伪目标有两点原因：\n\n1. 避免Makefile中只用来执行命令的目标与时间的文件出现名字冲突\n2. 提高执行make时的效率\n\n3. 文件清理操作clean作为伪目标的实现：\n\n``` makefile\n.PHONY : clean\nclean :\n\trm -rf *.o $(PROGRAM)\n```\n\n2. make 命令对于多个目录的并行和递归操作：\n\n``` makefile\nSUBDIRS = foo bar baz\n.PHONY : subdirs $(SUBDIRS)\nsubdirs : $(SUBDIRS)\n$(SUBDIRS) : \n\t$(MAKE) -C $@\nfoo: baz\n```\n\n​\t\t\t上述脚本实现了递归的调用三个子目录下的make命令。\n\n3. 伪目标实现多目标文件的生成\n\n   如果想要在一个Makefile里控制生成多个可执行文件，也可以借助伪目标实现：\n\n   ``` makefile\n   .PHONY all\n   all : test1 test2 test3\n   test1 : test1.o\n   \tgcc -o $@ $^\n   test2 : test2.o\n   \tgcc -o $@ $^\n   test3 : test3.o\n   \tgcc -o $@ $^\n   ```\n\n   上述脚本通过声明一个all伪目标，实现同时生成test1, test2, test3三个目标可执行文件。\n\n## Makefile中的字符串处理函数\n\nMakefile中调用函数的语法：\n\n`$(<function> <arguments>)` 或者 `${<function> <arguments>}` \n\n其中function是函数名，arguments是参数列表。函数名和参数列表之间用空格分开，参数列表中的多个参数用逗号分隔。\n\n### 模式字符串替换函数\n\n使用格式：\n\n```makefile\n$(patsubst <pattern>, <replacement>, <text>)\n```\n\n说明：查找text中符合模式pattern的部分，如果找到匹配的，则用replacement替换。返回替换后的新字符串。\n\n常见用法示例：\n\n```makefile\nC_SOURCE = $(shell find . -name *.c)\nC_OBJECTS=$(patsubst %.c, %.o, $(C_SOURCE))\nmain : $(C_OBJECTS)\n\tgcc -o $@ $^\n$(C_OBJECTS) : $(C_SOURCE)\n```\n\n### 字符串替换函数\n\n``` makefile\n$(subst <from>, <to>, <text>)\n```\n\n将text字符串中的from替换成to，返回替换后的新字符串\n\n用法示例：\n\n``` makefile\nOBJ = $(subst Beijing, Shanghai, I love Beijing)\nall:\n\t@echo $(OBJ)\t# 显示 I love Shanghai\n```\n\n### 去空格函数\n\n```makefile\n$(strip <string>)\n```\n\n去掉string开头和结尾的空格，并且将中间连续多个空格合并为一个空格。返回去空格后的字符串。\n\n### 字符串查找函数\n\n```makefile\n$(findstring <find>, <in>)\n```\n\n在in中查找find，如果查找的目标字符串存在，返回目标字符串，如果不存在返回空。\n\n用法示例\n\n```makefile\nOBJ = $(findstring you, I hate you)\nall:\n\t@echo $(OBJ)\t# 显示 you\n```\n\n### 模式过滤函数\n\n``` makefile\n$(filter <pattern>, <text>)\n```\n\n过滤出text中符合模式pattern的字符串，可以有多个pattern，返回所有符合pattern的字符串。\n\n用法示例：\n\n``` makefile\nOBJ = $(filter %.c %.o, foo1.c foo2.o foo3.s)\nall:\n\t@echo $(OBJ)\t#显示foo1.c foo2.o\n```\n\n### 反向过滤函数\n\n``` makefile\n$(filter-out <pattern>, <text>)\n```\n\n与filter函数相反，滤除所有符合pattern模式的字符串，返回所有不符合pattern的字符串。\n\n``` makefile\nOBJ = $(filter-out %.c %.o, foo1.c foo2.o foo3.s)\nall:\n\t@echo $(OBJ)\t#显示foo3.s\n```\n\n### 排序函数\n\n``` makefile\n$(sort <list>)\n```\n\n将list中的单词按照单词升序排序，返回排序后的字符串\n\n示例：\n\n``` makefile\nOBJ = $(sort orange apple pear apple)\nall: \n\t@echo $(OBJ) # 显示 apple orange pear\n```\n\n**notice** : sort会去掉重复的字符串\n\n### 去单词函数\n\n``` makefile\n$(word <n>, <text>)\n```\n\n取出字符串text中的第n个单词，返回取出的第n个单词。\n\n示例：\n\n```makefile\nOBJ = $(word 2, foo1.c foo2.c foo3.c)\nall:\n\t@echo $(OBJ)\t# 显示 foo2.c\n```\n\n## Makefile 中的文件名操作函数\n\n### 取目录函数\n\n``` makefile\n$(dir <names>)\n```\n\n从文件名序列names中取出所有文件的目录部分，如果文件名不包含任何路径，则取出的是“./”。返回文件序列的目录部分。\n\n### 取文件函数\n\n``` makefile\n$(notdir <names>)\n```\n\n从文件名序列names中取出所欲的非目录部分，返回取出的非目录部分。\n\n### 取后缀函数\n\n``` makefile\n$(suffix <names>)\n```\n\n从文件名序列names中取出各个文件的后缀名，如果文件名没有后缀，则取出结果为空，返回取出的后缀名序列。\n\n### 取前缀函数\n\n``` makefile\n$(basename <names>)\n```\n\n从文件名序列names中取出各个文件名的前缀部分（包含路径），返回取出的前缀名序列。\n\n### 添加后缀名函数\n\n``` makefile\n$(addsuffix <suffix>, <names>)\n```\n\n将后缀suffix添加到文件名列表names中的每个单词后面。返回添加后缀后的文件名序列。\n\n### 添加前缀名函数\n\n```makefile\n$(addprefix <prefix>, <names>)\n```\n\n将前缀prefix添加到文件名序列names中的每个单词前面，返回添加前缀之后的文件名序列。\n\n### 链接函数\n\n```makefile\n$(join <list1>, <list2>)\n```\n\n将list2中的单词一一对应的拼接到list1中的单词后，如果list1的单词比list2多，那么list1后面多出来的单词保持不变。如果list1的单词比list2少，那么list2后面多出来的单词保持不变。返回拼接之后的单词序列\n\n### 获取匹配模式文件名函数\n\n```makefile\n$(wildcard PATTERN)\n```\n\n列出当前目录下所有符合模式的PATTERN格式的文件名，返回由空格分隔的当前目录下所有符合PATTERN模式的文件名。\n\n### Exam\n\n```makefile\nOBJ = $(dir src/main.c src/module1.c inc/module1.h bsp.h)\nall:\n\t@echo $(OBJ)\t#显示 src/ src/ inc/ ./\n\t\nOBJ = $(notdir src/main.c src/module1.c inc/module1.h bsp.h)\nall:\n\t@echo $(OBJ)\t#显示main.c module1.c module1.h bsp.h\n\t\nOBJ = $(suffix src/main.c src/module1.c inc/module1.h bsp.h)\nall:\n\t@echo $(OBJ)\t#显示.c .c .h .h\n\t\nOBJ = $(basename src/main.c src/module1.c inc/module1.h bsp.h)\nall:\n\t@echo $(OBJ)\t#显示 src/main src/module1 inc/module1 bsp\n\nOBJ = $(addsuffix .c, src/main src/module1)\nall:\n\t@echo $(OBJ)\t#显示 src/main.c src/module1.c\n\t\nOBJ = $(addprefix src/, main.c module1.c)\nall:\n\t@echo $(OBJ)\t#显示 src/main.c src/module1.c\n\t\nOBJ = $(join main module1 module2, .c .h)\nall:\n\t@echo $(OBJ)\t#显示 main.c module1.h module2\n\t\nOBJ = $(wildcard *.c *.h)\nmain : $(OBJ)\n\tgcc -o $@ $^\n\t\n```\n\n## Makefile其他常用函数\n\n### 遍历函数\n\n``` makefile\n$(foreach <var>, <list>, <text>)\n```\n\n把参数list中的单词逐一取出放到参数var所指定的变量中，然后再执行text所包含的表达式，最终遍历完成后返回由空格分隔的遍历执行结果。\n\n**Notice** foreach函数中的var是一个临时变量，作用域只在该函数中，执行结束后就不再起作用。\n\n```makefile\nname = main module1 module2\nfiles = $(foreach n, $(name), $(n).o)\nall:\n\t@echo $(files)  #显示 main.o module1.o module2.o\n```\n\n### 条件执行函数\n\n```makefile\n$(if <condition>, <then-part>)\n$(if <condition>, <then-part>, <else-part>)\n```\n\n当condition为真，则执行then-part部分，否则执行else-part部分，返回执行结果，如果condition为假且else-part为空，则返回空字符串。condition为真的条件为condition为非空字符串。\n\n```makefile\nOBJ = foo.c\nOBJ = $(if $(OBJ), $(OBJ), main.c)\nall:\n\t@echo $(OBJ)\t\t#显示 foo.c\n```\n\n### 参数替换函数\n\n```makefile\n$(call <expression>, <parm1>, <parm2>, <parm3>, ...)\n```\n\nexpression是一个包含参数的表达式，但call被执行时，expression中的参数变量$(1)，\\$(2)，\\$(3)等会被后面的参数parm1， parm2, parm3依次取代。最终返回替换完之后expression的值。\n\n``` makefile\nfiles = $(2).c $(1).c\nobj = $(call files, main, module)\nall:\n\t@echo $(obj)\t#显示 module.c main.c\n```\n\n### 变量属性函数\n\n```makefile\n$(origin <variable>)\n```\n\norigin 函数不会操作变量的值，他只会返回这个变量的来源。这里variable是变量的名字，不应该是引用，最好不要在variable中使用$字符。下面是origin函数的返回值：\n\n| 返回值       | 说明                                                 |\n| ------------ | ---------------------------------------------------- |\n| undefined    | variable从没有定义过                                 |\n| default      | variable是默认定义的变量，如CC                       |\n| environment  | variable是一个环境变量，并且makefile执行时没有-e选项 |\n| file         | variable是在Makefile中定义的变量                     |\n| command line | variable这个变量是被命令执行的                       |\n| override     | variable是被override指示符重新定义的                 |\n| automatic    | variable是一个命令行中的自动化变量                   |\n\n## Makefile的文件包含与嵌套执行\n\n Makefile中可以通过include关键字来包含其他文件，当make命令遇到include关键字时，会暂停读取当前的Makefile，而是取读取include包含的文件，读取结束后再继续运行Makefile文件。具体用法如下：\n\n```makefile\ninclude <filenames>\n-include <filenames>\n```\n\n上述两种使用方式的区别在于：\n\n- 使用 `include <filenames>` ，make 在处理程序的时候，文件列表中的任意一个文件不存在的时候或者是没有规则去创建这个文件的时候，make 程序将会提示错误并保存退出。\n- 使用 `-include <filenames>`，当包含的文件不存在或者是没有规则去创建它的时候，make 将会继续执行程序，只有真正由于不能完成终极目标重建的时候我们的程序才会提示错误保存退出。\n\n**Notice** :使用include包含进来的 Makefile 文件中，如果存在函数或者是变量的引用，它们会在包含的 Makefile 中展开。\n\n### Makefile嵌套执行的两种方式\n\n```makefile\nsubsystem:\n\tcd subdir && $(MAKE)\n```\n\n上述脚本使当前的make命令切换目录到指定的目录subdir，该目录下也有一个Makefile文件用于描述subdir下文件的编译规则，然后会再该目录下执行make命令，执行完之后再返回外层的make执行中。这样实现了make的嵌套执行，最外层的Makefile一般称为总控Makefile。\n\n另一种写法是：\n\n```makefile\nsubsystem:\n\t$(MAKE) -C subdir\n```\n\nmake的嵌套执行过程中，有一个系统变量“CURDIR”，它表示make的工作目录。当使用-C选项时，命令就会进入指定的目录中，此变量也会被重新赋值。\n\n### Make嵌套执行时的参数传递\n\n使用make嵌套执行时，如果需要传递变量，可以如下使用：\n\n```makefile\nexport <variable>\n```\n\n如果需要传递所有变量，直接使用export不添加变量名即可。\n\n有两个变量SHELL和MAKEFLAGS在不管是否使用export关键字的情况下都会传递给被嵌套的Makefile。\n\n","source":"_posts/Makefile-Learning-Notes.md","raw":"---\ntitle: Makefile Learning Notes\ndate: 2022-09-29 19:11:06\ncategories: Learning\ntags: \n  - embedded\n  - Linux\n---\n\n## 基本语法与规则\n\nMakefile 描述的是文件编译的规则，一条规则主要由两部分组成，依赖关系和命令：\n\n```makefile\ntargets : prerequisites\n\tcommand\n```\n\n- targets: 规则的目标，可以是.o，可以是可执行文件，还可以是一个标签\n- prerequisites: 生成目标的依赖文件，可以是多个或者没有\n- command: make时需要执行的命令，可以是任意的shell命令，可以有多条命令，每条命令占一行。\n\n<!--more-->\n\nMakefile中主要包含的内容：\n\n1. 显示规则：显式说明如何生成一个目标文件\n2. 隐晦规则：make命令支持自动推导功能\n3. 变量的定义：Makefile中可以定义一系列变量，其用法与shell中的变量类似。\n4. 文件指示：可以在一个makefile中引用另一个makefile，类似c中的include。可以根据某些情况制定makefile中的有效部分，类似c中的条件编译。还可以自定义多行的命令。\n5. 注释：与shell相同，用#号注释。\n\nmake的执行过程：\n\n在shell中执行make之后，会自动搜索Makefile文件，并且将脚本中的第一条规则\n\n定义的目标作为最终目标，然后检查目标的依赖，这时有三种情况：\n\n1. 如果依赖的中间文件不存在，则会根据规则生成中间文件\n2. 如果依赖的中间文件存在，并且没有它所依赖的生成文件新，则会重新生成这个中间文件。\n3. 如果依赖的中间文件存在，并且它所依赖的生成文件也没有更新，则不会重新生成。\n\n## Makefile 中的通配符\n\nMakefile 支持shell中的通配符，如下：\n\n| 通配符 | 说明                   |\n| ------ | ---------------------- |\n| *      | 匹配0个或多个任意字符  |\n| ?      | 匹配任意一个字符       |\n| []     | 匹配方括号中制定的字符 |\n\n通配符在引用变量时的使用，在写依赖规则时，如果直接使用有通配符的变量，会出现错误。如\n\n``` makefile\nobj = *.c\ntest : $(obj)\n\tgcc -o $@ $^\n```\n\n当按如上规则make时，会报错找不到*.c。这是因为变量引用中的通配符并不会被展开。而如果想在引用的变量中使用通配符，则需要借助wildcard函数，这个函数会在引用变量时进行通配符的展开，如：\n\n``` makefile\nobj = $(wildcard *.c)\ntest : $(obj)\n\tgcc -o $@ $^\n```\n\nMakefile 中还支持 % 通配符，也是匹配任意个字符，\n\n``` makefile\ntest : test1.o test2.o\n\tgcc -o $@ $^\n%.o : %.c\n\tgcc -o $@ $^\n```\n\n%.o会把所有.o文件组合成一个列表，每次从列表中取出一个文件，然后找到文件中和%名称相同的.c文件，然后执行下面的文件，直至列表中的文件取完。这个属于Makefile中静态模规则：规则存在多个目标，规则存在多个目标，并且不同的目标可以根据目标文件的名字自动构造出依赖文件。\n\n## Makefile中的变量\n\n### 变量的定义\n\n`变量名称 = 值列表`\n\n变量名称可以由字母数字和下划线构成，等号左右的空格没有要求，值列表可以是0项，也可以是多项，中间用空格分隔。\n\n``` makefile\nOBJ = a.o b.o c.o\ntest : $(OBJ)\n\tgcc -o test $(OBJ)\n```\n\n### 变量的基本赋值\n\n- 简单赋值(:=)   编程语句中的常规赋值方式，只对当前语句的变量有效\n- 递归赋值(=)    所有目标变量相关的变量都会受影响，赋值语句可能影响多个变量\n- 条件赋值(?=)   如果变量未定义，则使用符号中的值定义变量，\n- 追加赋值(+=)   在变量的值列表后面追加一项新的值\n\n``` makefile\nx = abc\ny = $(x)d\nx := efg\t# 简单赋值 x=efg, y=abcd\nx = efg\t\t# 递归赋值 x=efg, y=efgd\nx ?= efg\t# 条件赋值 x=abc, y=abcd\nx += efg\t# 追加赋值 x=abc efg, y=abcd\n\n```\n\n### 自动化变量\n\n| 自动化变量 | 说明                                                         |\n| :--------: | ------------------------------------------------------------ |\n|     $@     | 表示规则的目标文件名。如果目标是一个文档文件（Linux 中，一般成 .a 文件为文档文件，也成为静态的库文件）， 那么它代表这个文档的文件名。在多目标模式规则中，它代表的是触发规则被执行的文件名。 |\n|     $%     | 当目标文件是一个静态库文件时，代表静态库的一个成员名。       |\n|     $<     | 规则的第一个依赖的文件名。如果是一个目标文件使用隐含的规则来重建，则它代表由隐含规则加入的第一个依赖文件。 |\n|     $?     | 所有比目标文件更新的依赖文件列表，空格分隔。如果目标文件时静态库文件，代表的是库文件（.o 文件）。 |\n|     $^     | 代表的是所有依赖文件列表，使用空格分隔。如果目标是静态库文件，它所代表的只能是所有的库成员（.o 文件）名。 一个文件可重复的出现在目标的依赖中，变量$^ 只记录它的第一次引用的情况。就是说会去掉重复的依赖文件。 |\n|     $+     | 类似“$^”，但是它保留了依赖文件中重复出现的文件。主要用在程序链接时库的交叉引用场合。 |\n|     $*     | 在模式规则和静态模式规则中，代表“茎”。“茎”是目标模式中“%”所代表的部分（当文件名中存在目录时， “茎”也包含目录部分）。 |\n\n## Makefile 目标文件搜索路径\n\n有两种方式可以制定Makefile脚本搜索目标文件的目录路径：一般搜索`VPATH` 和选择搜索`vpath`.\n\nVPATH和vpath的区别在于，VPATH是一个变量，而且是环境变量，使用时需要指定文件的路径；vpath是关键字，按照指定的模式搜索，搜索时不仅要加上路径，还要加上限值条件。\n\n### VPATH\n\n在Makefile中按如下形式使用VPATH指定搜索路径：\n\n``` makefile\nVPATH := src\n```\n\n当要指定多个路径时，不同的路径之间用空格或者冒号分隔。\n\n``` makefile\nVPAHT := path1:path2\n```\n\n ### vpath\n\nvpath按照给定模式在指定目录中搜索，使用方法如下：\n\n```makefile\n1. vpath PATTERN DIRECTORIES\n2. vpath PATTERN\n3. vpath\n```\n\n用法二的意思是清除符合模式 的搜索目录，用法3 单独使用vpath是清楚所有已设置的文件搜索路径。\n\n### 应用\n\n假设现在有一个工程，包含两个目录，src目录下包含main.c, module1.c, module2.c源文件，inc目录下包含module1.h, module2.h头文件。通过如下方式先声明文件搜索路径。\n\n``` makefile\nvpath %.c \tsrc\nvpath %.h\tinc\t\t## 或者使用 VPATH = src inc\nmain : main.o module1.o module2.o\n\tgcc -o $@ $<\nmain.o : main.c\n\tgcc -o $@ $^\nmodule1.o : module1.c module1.h\n\tgcc -o $@ $<\nmodule2.o : module2.c module2.h\n\tgcc -o $@ $<\n```\n\n## Makefile 隐含规则\n\n\n\n## Makefile 条件判断\n\n在实际工程中，经常会遇到要根据某个条件执行不同的编译操作的情况。这是就需要在Makefile中能够实现分条件执行语句的功能。Makefile中提供以下条件判断关键字：\n\n| 关键字 | 说明             |      |\n| ------ | ---------------- | ---- |\n| ifeq   | 判断参数是否相等 |      |\n| ifneq  | 判断参数是否不等 |      |\n| ifdef  | 判断是否有值     |      |\n| ifndef | 判断是否没有值   |      |\n\n### ifeq 和 ifneq\n\n使用语法\n\n``` makefile\nifeq (ARG1, arg2)\n# ifeq \"ARG1\" \"ARG2\"\n# ifeq 'ARG1' 'ARG2'\n\txxx\nelse\n\txxx\nendif\n```\n\n举例\n\n``` makefile\ngcc_libs = -lgnu\ndefault_libs = \nifeq ($(CC), gcc)\n\tlibs = $(gcc_libs)\nelse\n\tlibs = $(default_libs)\nendif\nfoo : $(objects)\n\t$(CC) -o foo $(objects) $(libs)\n```\n\n### ifdef 和 ifndef\n\n使用语法：\n\n``` makefile\nifdef VARIABLE_NAME\n```\n\n## Makefile 伪目标\n\n伪目标的含义是它并不会创建目标文件，但是会去执行这个目标下面的命令。使用伪目标有两点原因：\n\n1. 避免Makefile中只用来执行命令的目标与时间的文件出现名字冲突\n2. 提高执行make时的效率\n\n3. 文件清理操作clean作为伪目标的实现：\n\n``` makefile\n.PHONY : clean\nclean :\n\trm -rf *.o $(PROGRAM)\n```\n\n2. make 命令对于多个目录的并行和递归操作：\n\n``` makefile\nSUBDIRS = foo bar baz\n.PHONY : subdirs $(SUBDIRS)\nsubdirs : $(SUBDIRS)\n$(SUBDIRS) : \n\t$(MAKE) -C $@\nfoo: baz\n```\n\n​\t\t\t上述脚本实现了递归的调用三个子目录下的make命令。\n\n3. 伪目标实现多目标文件的生成\n\n   如果想要在一个Makefile里控制生成多个可执行文件，也可以借助伪目标实现：\n\n   ``` makefile\n   .PHONY all\n   all : test1 test2 test3\n   test1 : test1.o\n   \tgcc -o $@ $^\n   test2 : test2.o\n   \tgcc -o $@ $^\n   test3 : test3.o\n   \tgcc -o $@ $^\n   ```\n\n   上述脚本通过声明一个all伪目标，实现同时生成test1, test2, test3三个目标可执行文件。\n\n## Makefile中的字符串处理函数\n\nMakefile中调用函数的语法：\n\n`$(<function> <arguments>)` 或者 `${<function> <arguments>}` \n\n其中function是函数名，arguments是参数列表。函数名和参数列表之间用空格分开，参数列表中的多个参数用逗号分隔。\n\n### 模式字符串替换函数\n\n使用格式：\n\n```makefile\n$(patsubst <pattern>, <replacement>, <text>)\n```\n\n说明：查找text中符合模式pattern的部分，如果找到匹配的，则用replacement替换。返回替换后的新字符串。\n\n常见用法示例：\n\n```makefile\nC_SOURCE = $(shell find . -name *.c)\nC_OBJECTS=$(patsubst %.c, %.o, $(C_SOURCE))\nmain : $(C_OBJECTS)\n\tgcc -o $@ $^\n$(C_OBJECTS) : $(C_SOURCE)\n```\n\n### 字符串替换函数\n\n``` makefile\n$(subst <from>, <to>, <text>)\n```\n\n将text字符串中的from替换成to，返回替换后的新字符串\n\n用法示例：\n\n``` makefile\nOBJ = $(subst Beijing, Shanghai, I love Beijing)\nall:\n\t@echo $(OBJ)\t# 显示 I love Shanghai\n```\n\n### 去空格函数\n\n```makefile\n$(strip <string>)\n```\n\n去掉string开头和结尾的空格，并且将中间连续多个空格合并为一个空格。返回去空格后的字符串。\n\n### 字符串查找函数\n\n```makefile\n$(findstring <find>, <in>)\n```\n\n在in中查找find，如果查找的目标字符串存在，返回目标字符串，如果不存在返回空。\n\n用法示例\n\n```makefile\nOBJ = $(findstring you, I hate you)\nall:\n\t@echo $(OBJ)\t# 显示 you\n```\n\n### 模式过滤函数\n\n``` makefile\n$(filter <pattern>, <text>)\n```\n\n过滤出text中符合模式pattern的字符串，可以有多个pattern，返回所有符合pattern的字符串。\n\n用法示例：\n\n``` makefile\nOBJ = $(filter %.c %.o, foo1.c foo2.o foo3.s)\nall:\n\t@echo $(OBJ)\t#显示foo1.c foo2.o\n```\n\n### 反向过滤函数\n\n``` makefile\n$(filter-out <pattern>, <text>)\n```\n\n与filter函数相反，滤除所有符合pattern模式的字符串，返回所有不符合pattern的字符串。\n\n``` makefile\nOBJ = $(filter-out %.c %.o, foo1.c foo2.o foo3.s)\nall:\n\t@echo $(OBJ)\t#显示foo3.s\n```\n\n### 排序函数\n\n``` makefile\n$(sort <list>)\n```\n\n将list中的单词按照单词升序排序，返回排序后的字符串\n\n示例：\n\n``` makefile\nOBJ = $(sort orange apple pear apple)\nall: \n\t@echo $(OBJ) # 显示 apple orange pear\n```\n\n**notice** : sort会去掉重复的字符串\n\n### 去单词函数\n\n``` makefile\n$(word <n>, <text>)\n```\n\n取出字符串text中的第n个单词，返回取出的第n个单词。\n\n示例：\n\n```makefile\nOBJ = $(word 2, foo1.c foo2.c foo3.c)\nall:\n\t@echo $(OBJ)\t# 显示 foo2.c\n```\n\n## Makefile 中的文件名操作函数\n\n### 取目录函数\n\n``` makefile\n$(dir <names>)\n```\n\n从文件名序列names中取出所有文件的目录部分，如果文件名不包含任何路径，则取出的是“./”。返回文件序列的目录部分。\n\n### 取文件函数\n\n``` makefile\n$(notdir <names>)\n```\n\n从文件名序列names中取出所欲的非目录部分，返回取出的非目录部分。\n\n### 取后缀函数\n\n``` makefile\n$(suffix <names>)\n```\n\n从文件名序列names中取出各个文件的后缀名，如果文件名没有后缀，则取出结果为空，返回取出的后缀名序列。\n\n### 取前缀函数\n\n``` makefile\n$(basename <names>)\n```\n\n从文件名序列names中取出各个文件名的前缀部分（包含路径），返回取出的前缀名序列。\n\n### 添加后缀名函数\n\n``` makefile\n$(addsuffix <suffix>, <names>)\n```\n\n将后缀suffix添加到文件名列表names中的每个单词后面。返回添加后缀后的文件名序列。\n\n### 添加前缀名函数\n\n```makefile\n$(addprefix <prefix>, <names>)\n```\n\n将前缀prefix添加到文件名序列names中的每个单词前面，返回添加前缀之后的文件名序列。\n\n### 链接函数\n\n```makefile\n$(join <list1>, <list2>)\n```\n\n将list2中的单词一一对应的拼接到list1中的单词后，如果list1的单词比list2多，那么list1后面多出来的单词保持不变。如果list1的单词比list2少，那么list2后面多出来的单词保持不变。返回拼接之后的单词序列\n\n### 获取匹配模式文件名函数\n\n```makefile\n$(wildcard PATTERN)\n```\n\n列出当前目录下所有符合模式的PATTERN格式的文件名，返回由空格分隔的当前目录下所有符合PATTERN模式的文件名。\n\n### Exam\n\n```makefile\nOBJ = $(dir src/main.c src/module1.c inc/module1.h bsp.h)\nall:\n\t@echo $(OBJ)\t#显示 src/ src/ inc/ ./\n\t\nOBJ = $(notdir src/main.c src/module1.c inc/module1.h bsp.h)\nall:\n\t@echo $(OBJ)\t#显示main.c module1.c module1.h bsp.h\n\t\nOBJ = $(suffix src/main.c src/module1.c inc/module1.h bsp.h)\nall:\n\t@echo $(OBJ)\t#显示.c .c .h .h\n\t\nOBJ = $(basename src/main.c src/module1.c inc/module1.h bsp.h)\nall:\n\t@echo $(OBJ)\t#显示 src/main src/module1 inc/module1 bsp\n\nOBJ = $(addsuffix .c, src/main src/module1)\nall:\n\t@echo $(OBJ)\t#显示 src/main.c src/module1.c\n\t\nOBJ = $(addprefix src/, main.c module1.c)\nall:\n\t@echo $(OBJ)\t#显示 src/main.c src/module1.c\n\t\nOBJ = $(join main module1 module2, .c .h)\nall:\n\t@echo $(OBJ)\t#显示 main.c module1.h module2\n\t\nOBJ = $(wildcard *.c *.h)\nmain : $(OBJ)\n\tgcc -o $@ $^\n\t\n```\n\n## Makefile其他常用函数\n\n### 遍历函数\n\n``` makefile\n$(foreach <var>, <list>, <text>)\n```\n\n把参数list中的单词逐一取出放到参数var所指定的变量中，然后再执行text所包含的表达式，最终遍历完成后返回由空格分隔的遍历执行结果。\n\n**Notice** foreach函数中的var是一个临时变量，作用域只在该函数中，执行结束后就不再起作用。\n\n```makefile\nname = main module1 module2\nfiles = $(foreach n, $(name), $(n).o)\nall:\n\t@echo $(files)  #显示 main.o module1.o module2.o\n```\n\n### 条件执行函数\n\n```makefile\n$(if <condition>, <then-part>)\n$(if <condition>, <then-part>, <else-part>)\n```\n\n当condition为真，则执行then-part部分，否则执行else-part部分，返回执行结果，如果condition为假且else-part为空，则返回空字符串。condition为真的条件为condition为非空字符串。\n\n```makefile\nOBJ = foo.c\nOBJ = $(if $(OBJ), $(OBJ), main.c)\nall:\n\t@echo $(OBJ)\t\t#显示 foo.c\n```\n\n### 参数替换函数\n\n```makefile\n$(call <expression>, <parm1>, <parm2>, <parm3>, ...)\n```\n\nexpression是一个包含参数的表达式，但call被执行时，expression中的参数变量$(1)，\\$(2)，\\$(3)等会被后面的参数parm1， parm2, parm3依次取代。最终返回替换完之后expression的值。\n\n``` makefile\nfiles = $(2).c $(1).c\nobj = $(call files, main, module)\nall:\n\t@echo $(obj)\t#显示 module.c main.c\n```\n\n### 变量属性函数\n\n```makefile\n$(origin <variable>)\n```\n\norigin 函数不会操作变量的值，他只会返回这个变量的来源。这里variable是变量的名字，不应该是引用，最好不要在variable中使用$字符。下面是origin函数的返回值：\n\n| 返回值       | 说明                                                 |\n| ------------ | ---------------------------------------------------- |\n| undefined    | variable从没有定义过                                 |\n| default      | variable是默认定义的变量，如CC                       |\n| environment  | variable是一个环境变量，并且makefile执行时没有-e选项 |\n| file         | variable是在Makefile中定义的变量                     |\n| command line | variable这个变量是被命令执行的                       |\n| override     | variable是被override指示符重新定义的                 |\n| automatic    | variable是一个命令行中的自动化变量                   |\n\n## Makefile的文件包含与嵌套执行\n\n Makefile中可以通过include关键字来包含其他文件，当make命令遇到include关键字时，会暂停读取当前的Makefile，而是取读取include包含的文件，读取结束后再继续运行Makefile文件。具体用法如下：\n\n```makefile\ninclude <filenames>\n-include <filenames>\n```\n\n上述两种使用方式的区别在于：\n\n- 使用 `include <filenames>` ，make 在处理程序的时候，文件列表中的任意一个文件不存在的时候或者是没有规则去创建这个文件的时候，make 程序将会提示错误并保存退出。\n- 使用 `-include <filenames>`，当包含的文件不存在或者是没有规则去创建它的时候，make 将会继续执行程序，只有真正由于不能完成终极目标重建的时候我们的程序才会提示错误保存退出。\n\n**Notice** :使用include包含进来的 Makefile 文件中，如果存在函数或者是变量的引用，它们会在包含的 Makefile 中展开。\n\n### Makefile嵌套执行的两种方式\n\n```makefile\nsubsystem:\n\tcd subdir && $(MAKE)\n```\n\n上述脚本使当前的make命令切换目录到指定的目录subdir，该目录下也有一个Makefile文件用于描述subdir下文件的编译规则，然后会再该目录下执行make命令，执行完之后再返回外层的make执行中。这样实现了make的嵌套执行，最外层的Makefile一般称为总控Makefile。\n\n另一种写法是：\n\n```makefile\nsubsystem:\n\t$(MAKE) -C subdir\n```\n\nmake的嵌套执行过程中，有一个系统变量“CURDIR”，它表示make的工作目录。当使用-C选项时，命令就会进入指定的目录中，此变量也会被重新赋值。\n\n### Make嵌套执行时的参数传递\n\n使用make嵌套执行时，如果需要传递变量，可以如下使用：\n\n```makefile\nexport <variable>\n```\n\n如果需要传递所有变量，直接使用export不添加变量名即可。\n\n有两个变量SHELL和MAKEFLAGS在不管是否使用export关键字的情况下都会传递给被嵌套的Makefile。\n\n","slug":"Makefile-Learning-Notes","published":1,"updated":"2022-09-30T17:04:51.461Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl8oshjpx000b16u78mlqhz2p","content":"<h2 id=\"基本语法与规则\"><a href=\"#基本语法与规则\" class=\"headerlink\" title=\"基本语法与规则\"></a>基本语法与规则</h2><p>Makefile 描述的是文件编译的规则，一条规则主要由两部分组成，依赖关系和命令：</p>\n<figure class=\"highlight makefile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">targets : prerequisites</span><br><span class=\"line\">\tcommand</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>targets: 规则的目标，可以是.o，可以是可执行文件，还可以是一个标签</li>\n<li>prerequisites: 生成目标的依赖文件，可以是多个或者没有</li>\n<li>command: make时需要执行的命令，可以是任意的shell命令，可以有多条命令，每条命令占一行。</li>\n</ul>\n<span id=\"more\"></span>\n\n<p>Makefile中主要包含的内容：</p>\n<ol>\n<li>显示规则：显式说明如何生成一个目标文件</li>\n<li>隐晦规则：make命令支持自动推导功能</li>\n<li>变量的定义：Makefile中可以定义一系列变量，其用法与shell中的变量类似。</li>\n<li>文件指示：可以在一个makefile中引用另一个makefile，类似c中的include。可以根据某些情况制定makefile中的有效部分，类似c中的条件编译。还可以自定义多行的命令。</li>\n<li>注释：与shell相同，用#号注释。</li>\n</ol>\n<p>make的执行过程：</p>\n<p>在shell中执行make之后，会自动搜索Makefile文件，并且将脚本中的第一条规则</p>\n<p>定义的目标作为最终目标，然后检查目标的依赖，这时有三种情况：</p>\n<ol>\n<li>如果依赖的中间文件不存在，则会根据规则生成中间文件</li>\n<li>如果依赖的中间文件存在，并且没有它所依赖的生成文件新，则会重新生成这个中间文件。</li>\n<li>如果依赖的中间文件存在，并且它所依赖的生成文件也没有更新，则不会重新生成。</li>\n</ol>\n<h2 id=\"Makefile-中的通配符\"><a href=\"#Makefile-中的通配符\" class=\"headerlink\" title=\"Makefile 中的通配符\"></a>Makefile 中的通配符</h2><p>Makefile 支持shell中的通配符，如下：</p>\n<table>\n<thead>\n<tr>\n<th>通配符</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>*</td>\n<td>匹配0个或多个任意字符</td>\n</tr>\n<tr>\n<td>?</td>\n<td>匹配任意一个字符</td>\n</tr>\n<tr>\n<td>[]</td>\n<td>匹配方括号中制定的字符</td>\n</tr>\n</tbody></table>\n<p>通配符在引用变量时的使用，在写依赖规则时，如果直接使用有通配符的变量，会出现错误。如</p>\n<figure class=\"highlight makefile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">obj = *.c</span><br><span class=\"line\">test : <span class=\"variable\">$(obj)</span></span><br><span class=\"line\">\tgcc -o <span class=\"variable\">$@</span> <span class=\"variable\">$^</span></span><br></pre></td></tr></table></figure>\n\n<p>当按如上规则make时，会报错找不到*.c。这是因为变量引用中的通配符并不会被展开。而如果想在引用的变量中使用通配符，则需要借助wildcard函数，这个函数会在引用变量时进行通配符的展开，如：</p>\n<figure class=\"highlight makefile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">obj = <span class=\"variable\">$(<span class=\"built_in\">wildcard</span> *.c)</span></span><br><span class=\"line\">test : <span class=\"variable\">$(obj)</span></span><br><span class=\"line\">\tgcc -o <span class=\"variable\">$@</span> <span class=\"variable\">$^</span></span><br></pre></td></tr></table></figure>\n\n<p>Makefile 中还支持 % 通配符，也是匹配任意个字符，</p>\n<figure class=\"highlight makefile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">test : test1.o test2.o</span><br><span class=\"line\">\tgcc -o <span class=\"variable\">$@</span> <span class=\"variable\">$^</span></span><br><span class=\"line\">%.o : %.c</span><br><span class=\"line\">\tgcc -o <span class=\"variable\">$@</span> <span class=\"variable\">$^</span></span><br></pre></td></tr></table></figure>\n\n<p>%.o会把所有.o文件组合成一个列表，每次从列表中取出一个文件，然后找到文件中和%名称相同的.c文件，然后执行下面的文件，直至列表中的文件取完。这个属于Makefile中静态模规则：规则存在多个目标，规则存在多个目标，并且不同的目标可以根据目标文件的名字自动构造出依赖文件。</p>\n<h2 id=\"Makefile中的变量\"><a href=\"#Makefile中的变量\" class=\"headerlink\" title=\"Makefile中的变量\"></a>Makefile中的变量</h2><h3 id=\"变量的定义\"><a href=\"#变量的定义\" class=\"headerlink\" title=\"变量的定义\"></a>变量的定义</h3><p><code>变量名称 = 值列表</code></p>\n<p>变量名称可以由字母数字和下划线构成，等号左右的空格没有要求，值列表可以是0项，也可以是多项，中间用空格分隔。</p>\n<figure class=\"highlight makefile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">OBJ = a.o b.o c.o</span><br><span class=\"line\">test : <span class=\"variable\">$(OBJ)</span></span><br><span class=\"line\">\tgcc -o test <span class=\"variable\">$(OBJ)</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"变量的基本赋值\"><a href=\"#变量的基本赋值\" class=\"headerlink\" title=\"变量的基本赋值\"></a>变量的基本赋值</h3><ul>\n<li>简单赋值(:&#x3D;)   编程语句中的常规赋值方式，只对当前语句的变量有效</li>\n<li>递归赋值(&#x3D;)    所有目标变量相关的变量都会受影响，赋值语句可能影响多个变量</li>\n<li>条件赋值(?&#x3D;)   如果变量未定义，则使用符号中的值定义变量，</li>\n<li>追加赋值(+&#x3D;)   在变量的值列表后面追加一项新的值</li>\n</ul>\n<figure class=\"highlight makefile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">x = abc</span><br><span class=\"line\">y = <span class=\"variable\">$(x)</span>d</span><br><span class=\"line\">x := efg\t<span class=\"comment\"># 简单赋值 x=efg, y=abcd</span></span><br><span class=\"line\">x = efg\t\t<span class=\"comment\"># 递归赋值 x=efg, y=efgd</span></span><br><span class=\"line\">x ?= efg\t<span class=\"comment\"># 条件赋值 x=abc, y=abcd</span></span><br><span class=\"line\">x += efg\t<span class=\"comment\"># 追加赋值 x=abc efg, y=abcd</span></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"自动化变量\"><a href=\"#自动化变量\" class=\"headerlink\" title=\"自动化变量\"></a>自动化变量</h3><table>\n<thead>\n<tr>\n<th align=\"center\">自动化变量</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">$@</td>\n<td>表示规则的目标文件名。如果目标是一个文档文件（Linux 中，一般成 .a 文件为文档文件，也成为静态的库文件）， 那么它代表这个文档的文件名。在多目标模式规则中，它代表的是触发规则被执行的文件名。</td>\n</tr>\n<tr>\n<td align=\"center\">$%</td>\n<td>当目标文件是一个静态库文件时，代表静态库的一个成员名。</td>\n</tr>\n<tr>\n<td align=\"center\">$&lt;</td>\n<td>规则的第一个依赖的文件名。如果是一个目标文件使用隐含的规则来重建，则它代表由隐含规则加入的第一个依赖文件。</td>\n</tr>\n<tr>\n<td align=\"center\">$?</td>\n<td>所有比目标文件更新的依赖文件列表，空格分隔。如果目标文件时静态库文件，代表的是库文件（.o 文件）。</td>\n</tr>\n<tr>\n<td align=\"center\">$^</td>\n<td>代表的是所有依赖文件列表，使用空格分隔。如果目标是静态库文件，它所代表的只能是所有的库成员（.o 文件）名。 一个文件可重复的出现在目标的依赖中，变量$^ 只记录它的第一次引用的情况。就是说会去掉重复的依赖文件。</td>\n</tr>\n<tr>\n<td align=\"center\">$+</td>\n<td>类似“$^”，但是它保留了依赖文件中重复出现的文件。主要用在程序链接时库的交叉引用场合。</td>\n</tr>\n<tr>\n<td align=\"center\">$*</td>\n<td>在模式规则和静态模式规则中，代表“茎”。“茎”是目标模式中“%”所代表的部分（当文件名中存在目录时， “茎”也包含目录部分）。</td>\n</tr>\n</tbody></table>\n<h2 id=\"Makefile-目标文件搜索路径\"><a href=\"#Makefile-目标文件搜索路径\" class=\"headerlink\" title=\"Makefile 目标文件搜索路径\"></a>Makefile 目标文件搜索路径</h2><p>有两种方式可以制定Makefile脚本搜索目标文件的目录路径：一般搜索<code>VPATH</code> 和选择搜索<code>vpath</code>.</p>\n<p>VPATH和vpath的区别在于，VPATH是一个变量，而且是环境变量，使用时需要指定文件的路径；vpath是关键字，按照指定的模式搜索，搜索时不仅要加上路径，还要加上限值条件。</p>\n<h3 id=\"VPATH\"><a href=\"#VPATH\" class=\"headerlink\" title=\"VPATH\"></a>VPATH</h3><p>在Makefile中按如下形式使用VPATH指定搜索路径：</p>\n<figure class=\"highlight makefile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">VPATH := src</span><br></pre></td></tr></table></figure>\n\n<p>当要指定多个路径时，不同的路径之间用空格或者冒号分隔。</p>\n<figure class=\"highlight makefile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">VPAHT := path1:path2</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"vpath\"><a href=\"#vpath\" class=\"headerlink\" title=\"vpath\"></a>vpath</h3><p>vpath按照给定模式在指定目录中搜索，使用方法如下：</p>\n<figure class=\"highlight makefile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1. <span class=\"keyword\">vpath</span> PATTERN DIRECTORIES</span><br><span class=\"line\">2. <span class=\"keyword\">vpath</span> PATTERN</span><br><span class=\"line\">3. <span class=\"keyword\">vpath</span></span><br></pre></td></tr></table></figure>\n\n<p>用法二的意思是清除符合模式 的搜索目录，用法3 单独使用vpath是清楚所有已设置的文件搜索路径。</p>\n<h3 id=\"应用\"><a href=\"#应用\" class=\"headerlink\" title=\"应用\"></a>应用</h3><p>假设现在有一个工程，包含两个目录，src目录下包含main.c, module1.c, module2.c源文件，inc目录下包含module1.h, module2.h头文件。通过如下方式先声明文件搜索路径。</p>\n<figure class=\"highlight makefile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">vpath</span> %.c \tsrc</span><br><span class=\"line\"><span class=\"keyword\">vpath</span> %.h\tinc\t\t<span class=\"comment\">## 或者使用 VPATH = src inc</span></span><br><span class=\"line\">main : main.o module1.o module2.o</span><br><span class=\"line\">\tgcc -o <span class=\"variable\">$@</span> <span class=\"variable\">$&lt;</span></span><br><span class=\"line\">main.o : main.c</span><br><span class=\"line\">\tgcc -o <span class=\"variable\">$@</span> <span class=\"variable\">$^</span></span><br><span class=\"line\">module1.o : module1.c module1.h</span><br><span class=\"line\">\tgcc -o <span class=\"variable\">$@</span> <span class=\"variable\">$&lt;</span></span><br><span class=\"line\">module2.o : module2.c module2.h</span><br><span class=\"line\">\tgcc -o <span class=\"variable\">$@</span> <span class=\"variable\">$&lt;</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"Makefile-隐含规则\"><a href=\"#Makefile-隐含规则\" class=\"headerlink\" title=\"Makefile 隐含规则\"></a>Makefile 隐含规则</h2><h2 id=\"Makefile-条件判断\"><a href=\"#Makefile-条件判断\" class=\"headerlink\" title=\"Makefile 条件判断\"></a>Makefile 条件判断</h2><p>在实际工程中，经常会遇到要根据某个条件执行不同的编译操作的情况。这是就需要在Makefile中能够实现分条件执行语句的功能。Makefile中提供以下条件判断关键字：</p>\n<table>\n<thead>\n<tr>\n<th>关键字</th>\n<th>说明</th>\n<th></th>\n</tr>\n</thead>\n<tbody><tr>\n<td>ifeq</td>\n<td>判断参数是否相等</td>\n<td></td>\n</tr>\n<tr>\n<td>ifneq</td>\n<td>判断参数是否不等</td>\n<td></td>\n</tr>\n<tr>\n<td>ifdef</td>\n<td>判断是否有值</td>\n<td></td>\n</tr>\n<tr>\n<td>ifndef</td>\n<td>判断是否没有值</td>\n<td></td>\n</tr>\n</tbody></table>\n<h3 id=\"ifeq-和-ifneq\"><a href=\"#ifeq-和-ifneq\" class=\"headerlink\" title=\"ifeq 和 ifneq\"></a>ifeq 和 ifneq</h3><p>使用语法</p>\n<figure class=\"highlight makefile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">ifeq</span> (ARG1, arg2)</span><br><span class=\"line\"><span class=\"comment\"># ifeq &quot;ARG1&quot; &quot;ARG2&quot;</span></span><br><span class=\"line\"><span class=\"comment\"># ifeq &#x27;ARG1&#x27; &#x27;ARG2&#x27;</span></span><br><span class=\"line\">\txxx</span><br><span class=\"line\"><span class=\"keyword\">else</span></span><br><span class=\"line\">\txxx</span><br><span class=\"line\"><span class=\"keyword\">endif</span></span><br></pre></td></tr></table></figure>\n\n<p>举例</p>\n<figure class=\"highlight makefile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">gcc_libs = -lgnu</span><br><span class=\"line\">default_libs = </span><br><span class=\"line\"><span class=\"keyword\">ifeq</span> (<span class=\"variable\">$(CC)</span>, gcc)</span><br><span class=\"line\">\tlibs = <span class=\"variable\">$(gcc_libs)</span></span><br><span class=\"line\"><span class=\"keyword\">else</span></span><br><span class=\"line\">\tlibs = <span class=\"variable\">$(default_libs)</span></span><br><span class=\"line\"><span class=\"keyword\">endif</span></span><br><span class=\"line\">foo : <span class=\"variable\">$(objects)</span></span><br><span class=\"line\">\t<span class=\"variable\">$(CC)</span> -o foo <span class=\"variable\">$(objects)</span> <span class=\"variable\">$(libs)</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"ifdef-和-ifndef\"><a href=\"#ifdef-和-ifndef\" class=\"headerlink\" title=\"ifdef 和 ifndef\"></a>ifdef 和 ifndef</h3><p>使用语法：</p>\n<figure class=\"highlight makefile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">ifdef</span> VARIABLE_NAME</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"Makefile-伪目标\"><a href=\"#Makefile-伪目标\" class=\"headerlink\" title=\"Makefile 伪目标\"></a>Makefile 伪目标</h2><p>伪目标的含义是它并不会创建目标文件，但是会去执行这个目标下面的命令。使用伪目标有两点原因：</p>\n<ol>\n<li><p>避免Makefile中只用来执行命令的目标与时间的文件出现名字冲突</p>\n</li>\n<li><p>提高执行make时的效率</p>\n</li>\n<li><p>文件清理操作clean作为伪目标的实现：</p>\n</li>\n</ol>\n<figure class=\"highlight makefile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.PHONY : clean</span><br><span class=\"line\">clean :</span><br><span class=\"line\">\trm -rf *.o <span class=\"variable\">$(PROGRAM)</span></span><br></pre></td></tr></table></figure>\n\n<ol start=\"2\">\n<li>make 命令对于多个目录的并行和递归操作：</li>\n</ol>\n<figure class=\"highlight makefile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">SUBDIRS = foo bar baz</span><br><span class=\"line\">.PHONY : subdirs <span class=\"variable\">$(SUBDIRS)</span></span><br><span class=\"line\">subdirs : <span class=\"variable\">$(SUBDIRS)</span></span><br><span class=\"line\"><span class=\"variable\">$(SUBDIRS)</span> : </span><br><span class=\"line\">\t<span class=\"variable\">$(MAKE)</span> -C <span class=\"variable\">$@</span></span><br><span class=\"line\"><span class=\"section\">foo: baz</span></span><br></pre></td></tr></table></figure>\n\n<p>​\t\t\t上述脚本实现了递归的调用三个子目录下的make命令。</p>\n<ol start=\"3\">\n<li><p>伪目标实现多目标文件的生成</p>\n<p>如果想要在一个Makefile里控制生成多个可执行文件，也可以借助伪目标实现：</p>\n<figure class=\"highlight makefile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.PHONY all</span><br><span class=\"line\">all : test1 test2 test3</span><br><span class=\"line\">test1 : test1.o</span><br><span class=\"line\">\tgcc -o <span class=\"variable\">$@</span> <span class=\"variable\">$^</span></span><br><span class=\"line\">test2 : test2.o</span><br><span class=\"line\">\tgcc -o <span class=\"variable\">$@</span> <span class=\"variable\">$^</span></span><br><span class=\"line\">test3 : test3.o</span><br><span class=\"line\">\tgcc -o <span class=\"variable\">$@</span> <span class=\"variable\">$^</span></span><br></pre></td></tr></table></figure>\n\n<p>上述脚本通过声明一个all伪目标，实现同时生成test1, test2, test3三个目标可执行文件。</p>\n</li>\n</ol>\n<h2 id=\"Makefile中的字符串处理函数\"><a href=\"#Makefile中的字符串处理函数\" class=\"headerlink\" title=\"Makefile中的字符串处理函数\"></a>Makefile中的字符串处理函数</h2><p>Makefile中调用函数的语法：</p>\n<p><code>$(&lt;function&gt; &lt;arguments&gt;)</code> 或者 <code>$&#123;&lt;function&gt; &lt;arguments&gt;&#125;</code> </p>\n<p>其中function是函数名，arguments是参数列表。函数名和参数列表之间用空格分开，参数列表中的多个参数用逗号分隔。</p>\n<h3 id=\"模式字符串替换函数\"><a href=\"#模式字符串替换函数\" class=\"headerlink\" title=\"模式字符串替换函数\"></a>模式字符串替换函数</h3><p>使用格式：</p>\n<figure class=\"highlight makefile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"variable\">$(<span class=\"built_in\">patsubst</span> &lt;pattern&gt;, &lt;replacement&gt;, &lt;text&gt;)</span></span><br></pre></td></tr></table></figure>\n\n<p>说明：查找text中符合模式pattern的部分，如果找到匹配的，则用replacement替换。返回替换后的新字符串。</p>\n<p>常见用法示例：</p>\n<figure class=\"highlight makefile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">C_SOURCE = <span class=\"variable\">$(<span class=\"built_in\">shell</span> find . -name *.c)</span></span><br><span class=\"line\">C_OBJECTS=<span class=\"variable\">$(<span class=\"built_in\">patsubst</span> %.c, %.o, <span class=\"variable\">$(C_SOURCE)</span>)</span></span><br><span class=\"line\">main : <span class=\"variable\">$(C_OBJECTS)</span></span><br><span class=\"line\">\tgcc -o <span class=\"variable\">$@</span> <span class=\"variable\">$^</span></span><br><span class=\"line\"><span class=\"variable\">$(C_OBJECTS)</span> : <span class=\"variable\">$(C_SOURCE)</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"字符串替换函数\"><a href=\"#字符串替换函数\" class=\"headerlink\" title=\"字符串替换函数\"></a>字符串替换函数</h3><figure class=\"highlight makefile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"variable\">$(<span class=\"built_in\">subst</span> &lt;from&gt;, &lt;to&gt;, &lt;text&gt;)</span></span><br></pre></td></tr></table></figure>\n\n<p>将text字符串中的from替换成to，返回替换后的新字符串</p>\n<p>用法示例：</p>\n<figure class=\"highlight makefile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">OBJ = <span class=\"variable\">$(<span class=\"built_in\">subst</span> Beijing, Shanghai, I love Beijing)</span></span><br><span class=\"line\"><span class=\"section\">all:</span></span><br><span class=\"line\">\t@echo <span class=\"variable\">$(OBJ)</span>\t<span class=\"comment\"># 显示 I love Shanghai</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"去空格函数\"><a href=\"#去空格函数\" class=\"headerlink\" title=\"去空格函数\"></a>去空格函数</h3><figure class=\"highlight makefile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"variable\">$(<span class=\"built_in\">strip</span> &lt;string&gt;)</span></span><br></pre></td></tr></table></figure>\n\n<p>去掉string开头和结尾的空格，并且将中间连续多个空格合并为一个空格。返回去空格后的字符串。</p>\n<h3 id=\"字符串查找函数\"><a href=\"#字符串查找函数\" class=\"headerlink\" title=\"字符串查找函数\"></a>字符串查找函数</h3><figure class=\"highlight makefile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"variable\">$(<span class=\"built_in\">findstring</span> &lt;find&gt;, &lt;in&gt;)</span></span><br></pre></td></tr></table></figure>\n\n<p>在in中查找find，如果查找的目标字符串存在，返回目标字符串，如果不存在返回空。</p>\n<p>用法示例</p>\n<figure class=\"highlight makefile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">OBJ = <span class=\"variable\">$(<span class=\"built_in\">findstring</span> you, I hate you)</span></span><br><span class=\"line\"><span class=\"section\">all:</span></span><br><span class=\"line\">\t@echo <span class=\"variable\">$(OBJ)</span>\t<span class=\"comment\"># 显示 you</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"模式过滤函数\"><a href=\"#模式过滤函数\" class=\"headerlink\" title=\"模式过滤函数\"></a>模式过滤函数</h3><figure class=\"highlight makefile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"variable\">$(<span class=\"built_in\">filter</span> &lt;pattern&gt;, &lt;text&gt;)</span></span><br></pre></td></tr></table></figure>\n\n<p>过滤出text中符合模式pattern的字符串，可以有多个pattern，返回所有符合pattern的字符串。</p>\n<p>用法示例：</p>\n<figure class=\"highlight makefile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">OBJ = <span class=\"variable\">$(<span class=\"built_in\">filter</span> %.c %.o, foo1.c foo2.o foo3.s)</span></span><br><span class=\"line\"><span class=\"section\">all:</span></span><br><span class=\"line\">\t@echo <span class=\"variable\">$(OBJ)</span>\t<span class=\"comment\">#显示foo1.c foo2.o</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"反向过滤函数\"><a href=\"#反向过滤函数\" class=\"headerlink\" title=\"反向过滤函数\"></a>反向过滤函数</h3><figure class=\"highlight makefile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"variable\">$(<span class=\"built_in\">filter</span>-out &lt;pattern&gt;, &lt;text&gt;)</span></span><br></pre></td></tr></table></figure>\n\n<p>与filter函数相反，滤除所有符合pattern模式的字符串，返回所有不符合pattern的字符串。</p>\n<figure class=\"highlight makefile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">OBJ = <span class=\"variable\">$(<span class=\"built_in\">filter</span>-out %.c %.o, foo1.c foo2.o foo3.s)</span></span><br><span class=\"line\"><span class=\"section\">all:</span></span><br><span class=\"line\">\t@echo <span class=\"variable\">$(OBJ)</span>\t<span class=\"comment\">#显示foo3.s</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"排序函数\"><a href=\"#排序函数\" class=\"headerlink\" title=\"排序函数\"></a>排序函数</h3><figure class=\"highlight makefile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"variable\">$(<span class=\"built_in\">sort</span> &lt;list&gt;)</span></span><br></pre></td></tr></table></figure>\n\n<p>将list中的单词按照单词升序排序，返回排序后的字符串</p>\n<p>示例：</p>\n<figure class=\"highlight makefile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">OBJ = <span class=\"variable\">$(<span class=\"built_in\">sort</span> orange apple pear apple)</span></span><br><span class=\"line\"><span class=\"section\">all: </span></span><br><span class=\"line\">\t@echo <span class=\"variable\">$(OBJ)</span> <span class=\"comment\"># 显示 apple orange pear</span></span><br></pre></td></tr></table></figure>\n\n<p><strong>notice</strong> : sort会去掉重复的字符串</p>\n<h3 id=\"去单词函数\"><a href=\"#去单词函数\" class=\"headerlink\" title=\"去单词函数\"></a>去单词函数</h3><figure class=\"highlight makefile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"variable\">$(<span class=\"built_in\">word</span> &lt;n&gt;, &lt;text&gt;)</span></span><br></pre></td></tr></table></figure>\n\n<p>取出字符串text中的第n个单词，返回取出的第n个单词。</p>\n<p>示例：</p>\n<figure class=\"highlight makefile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">OBJ = <span class=\"variable\">$(<span class=\"built_in\">word</span> 2, foo1.c foo2.c foo3.c)</span></span><br><span class=\"line\"><span class=\"section\">all:</span></span><br><span class=\"line\">\t@echo <span class=\"variable\">$(OBJ)</span>\t<span class=\"comment\"># 显示 foo2.c</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"Makefile-中的文件名操作函数\"><a href=\"#Makefile-中的文件名操作函数\" class=\"headerlink\" title=\"Makefile 中的文件名操作函数\"></a>Makefile 中的文件名操作函数</h2><h3 id=\"取目录函数\"><a href=\"#取目录函数\" class=\"headerlink\" title=\"取目录函数\"></a>取目录函数</h3><figure class=\"highlight makefile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"variable\">$(<span class=\"built_in\">dir</span> &lt;names&gt;)</span></span><br></pre></td></tr></table></figure>\n\n<p>从文件名序列names中取出所有文件的目录部分，如果文件名不包含任何路径，则取出的是“.&#x2F;”。返回文件序列的目录部分。</p>\n<h3 id=\"取文件函数\"><a href=\"#取文件函数\" class=\"headerlink\" title=\"取文件函数\"></a>取文件函数</h3><figure class=\"highlight makefile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"variable\">$(<span class=\"built_in\">notdir</span> &lt;names&gt;)</span></span><br></pre></td></tr></table></figure>\n\n<p>从文件名序列names中取出所欲的非目录部分，返回取出的非目录部分。</p>\n<h3 id=\"取后缀函数\"><a href=\"#取后缀函数\" class=\"headerlink\" title=\"取后缀函数\"></a>取后缀函数</h3><figure class=\"highlight makefile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"variable\">$(<span class=\"built_in\">suffix</span> &lt;names&gt;)</span></span><br></pre></td></tr></table></figure>\n\n<p>从文件名序列names中取出各个文件的后缀名，如果文件名没有后缀，则取出结果为空，返回取出的后缀名序列。</p>\n<h3 id=\"取前缀函数\"><a href=\"#取前缀函数\" class=\"headerlink\" title=\"取前缀函数\"></a>取前缀函数</h3><figure class=\"highlight makefile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"variable\">$(<span class=\"built_in\">basename</span> &lt;names&gt;)</span></span><br></pre></td></tr></table></figure>\n\n<p>从文件名序列names中取出各个文件名的前缀部分（包含路径），返回取出的前缀名序列。</p>\n<h3 id=\"添加后缀名函数\"><a href=\"#添加后缀名函数\" class=\"headerlink\" title=\"添加后缀名函数\"></a>添加后缀名函数</h3><figure class=\"highlight makefile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"variable\">$(<span class=\"built_in\">addsuffix</span> &lt;<span class=\"built_in\">suffix</span>&gt;, &lt;names&gt;)</span></span><br></pre></td></tr></table></figure>\n\n<p>将后缀suffix添加到文件名列表names中的每个单词后面。返回添加后缀后的文件名序列。</p>\n<h3 id=\"添加前缀名函数\"><a href=\"#添加前缀名函数\" class=\"headerlink\" title=\"添加前缀名函数\"></a>添加前缀名函数</h3><figure class=\"highlight makefile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"variable\">$(<span class=\"built_in\">addprefix</span> &lt;prefix&gt;, &lt;names&gt;)</span></span><br></pre></td></tr></table></figure>\n\n<p>将前缀prefix添加到文件名序列names中的每个单词前面，返回添加前缀之后的文件名序列。</p>\n<h3 id=\"链接函数\"><a href=\"#链接函数\" class=\"headerlink\" title=\"链接函数\"></a>链接函数</h3><figure class=\"highlight makefile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"variable\">$(<span class=\"built_in\">join</span> &lt;list1&gt;, &lt;list2&gt;)</span></span><br></pre></td></tr></table></figure>\n\n<p>将list2中的单词一一对应的拼接到list1中的单词后，如果list1的单词比list2多，那么list1后面多出来的单词保持不变。如果list1的单词比list2少，那么list2后面多出来的单词保持不变。返回拼接之后的单词序列</p>\n<h3 id=\"获取匹配模式文件名函数\"><a href=\"#获取匹配模式文件名函数\" class=\"headerlink\" title=\"获取匹配模式文件名函数\"></a>获取匹配模式文件名函数</h3><figure class=\"highlight makefile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"variable\">$(<span class=\"built_in\">wildcard</span> PATTERN)</span></span><br></pre></td></tr></table></figure>\n\n<p>列出当前目录下所有符合模式的PATTERN格式的文件名，返回由空格分隔的当前目录下所有符合PATTERN模式的文件名。</p>\n<h3 id=\"Exam\"><a href=\"#Exam\" class=\"headerlink\" title=\"Exam\"></a>Exam</h3><figure class=\"highlight makefile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">OBJ = <span class=\"variable\">$(<span class=\"built_in\">dir</span> src/main.c src/module1.c inc/module1.h bsp.h)</span></span><br><span class=\"line\"><span class=\"section\">all:</span></span><br><span class=\"line\">\t@echo <span class=\"variable\">$(OBJ)</span>\t<span class=\"comment\">#显示 src/ src/ inc/ ./</span></span><br><span class=\"line\">\t</span><br><span class=\"line\">OBJ = <span class=\"variable\">$(<span class=\"built_in\">notdir</span> src/main.c src/module1.c inc/module1.h bsp.h)</span></span><br><span class=\"line\"><span class=\"section\">all:</span></span><br><span class=\"line\">\t@echo <span class=\"variable\">$(OBJ)</span>\t<span class=\"comment\">#显示main.c module1.c module1.h bsp.h</span></span><br><span class=\"line\">\t</span><br><span class=\"line\">OBJ = <span class=\"variable\">$(<span class=\"built_in\">suffix</span> src/main.c src/module1.c inc/module1.h bsp.h)</span></span><br><span class=\"line\"><span class=\"section\">all:</span></span><br><span class=\"line\">\t@echo <span class=\"variable\">$(OBJ)</span>\t<span class=\"comment\">#显示.c .c .h .h</span></span><br><span class=\"line\">\t</span><br><span class=\"line\">OBJ = <span class=\"variable\">$(<span class=\"built_in\">basename</span> src/main.c src/module1.c inc/module1.h bsp.h)</span></span><br><span class=\"line\"><span class=\"section\">all:</span></span><br><span class=\"line\">\t@echo <span class=\"variable\">$(OBJ)</span>\t<span class=\"comment\">#显示 src/main src/module1 inc/module1 bsp</span></span><br><span class=\"line\"></span><br><span class=\"line\">OBJ = <span class=\"variable\">$(<span class=\"built_in\">addsuffix</span> .c, src/main src/module1)</span></span><br><span class=\"line\"><span class=\"section\">all:</span></span><br><span class=\"line\">\t@echo <span class=\"variable\">$(OBJ)</span>\t<span class=\"comment\">#显示 src/main.c src/module1.c</span></span><br><span class=\"line\">\t</span><br><span class=\"line\">OBJ = <span class=\"variable\">$(<span class=\"built_in\">addprefix</span> src/, main.c module1.c)</span></span><br><span class=\"line\"><span class=\"section\">all:</span></span><br><span class=\"line\">\t@echo <span class=\"variable\">$(OBJ)</span>\t<span class=\"comment\">#显示 src/main.c src/module1.c</span></span><br><span class=\"line\">\t</span><br><span class=\"line\">OBJ = <span class=\"variable\">$(<span class=\"built_in\">join</span> main module1 module2, .c .h)</span></span><br><span class=\"line\"><span class=\"section\">all:</span></span><br><span class=\"line\">\t@echo <span class=\"variable\">$(OBJ)</span>\t<span class=\"comment\">#显示 main.c module1.h module2</span></span><br><span class=\"line\">\t</span><br><span class=\"line\">OBJ = <span class=\"variable\">$(<span class=\"built_in\">wildcard</span> *.c *.h)</span></span><br><span class=\"line\">main : <span class=\"variable\">$(OBJ)</span></span><br><span class=\"line\">\tgcc -o <span class=\"variable\">$@</span> <span class=\"variable\">$^</span></span><br><span class=\"line\">\t</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"Makefile其他常用函数\"><a href=\"#Makefile其他常用函数\" class=\"headerlink\" title=\"Makefile其他常用函数\"></a>Makefile其他常用函数</h2><h3 id=\"遍历函数\"><a href=\"#遍历函数\" class=\"headerlink\" title=\"遍历函数\"></a>遍历函数</h3><figure class=\"highlight makefile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"variable\">$(<span class=\"built_in\">foreach</span> &lt;var&gt;, &lt;list&gt;, &lt;text&gt;)</span></span><br></pre></td></tr></table></figure>\n\n<p>把参数list中的单词逐一取出放到参数var所指定的变量中，然后再执行text所包含的表达式，最终遍历完成后返回由空格分隔的遍历执行结果。</p>\n<p><strong>Notice</strong> foreach函数中的var是一个临时变量，作用域只在该函数中，执行结束后就不再起作用。</p>\n<figure class=\"highlight makefile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">name = main module1 module2</span><br><span class=\"line\">files = <span class=\"variable\">$(<span class=\"built_in\">foreach</span> n, <span class=\"variable\">$(name)</span>, <span class=\"variable\">$(n)</span>.o)</span></span><br><span class=\"line\"><span class=\"section\">all:</span></span><br><span class=\"line\">\t@echo <span class=\"variable\">$(files)</span>  <span class=\"comment\">#显示 main.o module1.o module2.o</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"条件执行函数\"><a href=\"#条件执行函数\" class=\"headerlink\" title=\"条件执行函数\"></a>条件执行函数</h3><figure class=\"highlight makefile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"variable\">$(<span class=\"built_in\">if</span> &lt;condition&gt;, &lt;then-part&gt;)</span></span><br><span class=\"line\"><span class=\"variable\">$(<span class=\"built_in\">if</span> &lt;condition&gt;, &lt;then-part&gt;, &lt;else-part&gt;)</span></span><br></pre></td></tr></table></figure>\n\n<p>当condition为真，则执行then-part部分，否则执行else-part部分，返回执行结果，如果condition为假且else-part为空，则返回空字符串。condition为真的条件为condition为非空字符串。</p>\n<figure class=\"highlight makefile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">OBJ = foo.c</span><br><span class=\"line\">OBJ = <span class=\"variable\">$(<span class=\"built_in\">if</span> <span class=\"variable\">$(OBJ)</span>, <span class=\"variable\">$(OBJ)</span>, main.c)</span></span><br><span class=\"line\"><span class=\"section\">all:</span></span><br><span class=\"line\">\t@echo <span class=\"variable\">$(OBJ)</span>\t\t<span class=\"comment\">#显示 foo.c</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"参数替换函数\"><a href=\"#参数替换函数\" class=\"headerlink\" title=\"参数替换函数\"></a>参数替换函数</h3><figure class=\"highlight makefile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"variable\">$(<span class=\"built_in\">call</span> &lt;expression&gt;, &lt;parm1&gt;, &lt;parm2&gt;, &lt;parm3&gt;, ...)</span></span><br></pre></td></tr></table></figure>\n\n<p>expression是一个包含参数的表达式，但call被执行时，expression中的参数变量$(1)，$(2)，$(3)等会被后面的参数parm1， parm2, parm3依次取代。最终返回替换完之后expression的值。</p>\n<figure class=\"highlight makefile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">files = $(2).c $(1).c</span><br><span class=\"line\">obj = <span class=\"variable\">$(<span class=\"built_in\">call</span> files, main, module)</span></span><br><span class=\"line\"><span class=\"section\">all:</span></span><br><span class=\"line\">\t@echo <span class=\"variable\">$(obj)</span>\t<span class=\"comment\">#显示 module.c main.c</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"变量属性函数\"><a href=\"#变量属性函数\" class=\"headerlink\" title=\"变量属性函数\"></a>变量属性函数</h3><figure class=\"highlight makefile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"variable\">$(<span class=\"built_in\">origin</span> &lt;variable&gt;)</span></span><br></pre></td></tr></table></figure>\n\n<p>origin 函数不会操作变量的值，他只会返回这个变量的来源。这里variable是变量的名字，不应该是引用，最好不要在variable中使用$字符。下面是origin函数的返回值：</p>\n<table>\n<thead>\n<tr>\n<th>返回值</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>undefined</td>\n<td>variable从没有定义过</td>\n</tr>\n<tr>\n<td>default</td>\n<td>variable是默认定义的变量，如CC</td>\n</tr>\n<tr>\n<td>environment</td>\n<td>variable是一个环境变量，并且makefile执行时没有-e选项</td>\n</tr>\n<tr>\n<td>file</td>\n<td>variable是在Makefile中定义的变量</td>\n</tr>\n<tr>\n<td>command line</td>\n<td>variable这个变量是被命令执行的</td>\n</tr>\n<tr>\n<td>override</td>\n<td>variable是被override指示符重新定义的</td>\n</tr>\n<tr>\n<td>automatic</td>\n<td>variable是一个命令行中的自动化变量</td>\n</tr>\n</tbody></table>\n<h2 id=\"Makefile的文件包含与嵌套执行\"><a href=\"#Makefile的文件包含与嵌套执行\" class=\"headerlink\" title=\"Makefile的文件包含与嵌套执行\"></a>Makefile的文件包含与嵌套执行</h2><p> Makefile中可以通过include关键字来包含其他文件，当make命令遇到include关键字时，会暂停读取当前的Makefile，而是取读取include包含的文件，读取结束后再继续运行Makefile文件。具体用法如下：</p>\n<figure class=\"highlight makefile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">include</span> &lt;filenames&gt;</span><br><span class=\"line\"><span class=\"keyword\">-include</span> &lt;filenames&gt;</span><br></pre></td></tr></table></figure>\n\n<p>上述两种使用方式的区别在于：</p>\n<ul>\n<li>使用 <code>include &lt;filenames&gt;</code> ，make 在处理程序的时候，文件列表中的任意一个文件不存在的时候或者是没有规则去创建这个文件的时候，make 程序将会提示错误并保存退出。</li>\n<li>使用 <code>-include &lt;filenames&gt;</code>，当包含的文件不存在或者是没有规则去创建它的时候，make 将会继续执行程序，只有真正由于不能完成终极目标重建的时候我们的程序才会提示错误保存退出。</li>\n</ul>\n<p><strong>Notice</strong> :使用include包含进来的 Makefile 文件中，如果存在函数或者是变量的引用，它们会在包含的 Makefile 中展开。</p>\n<h3 id=\"Makefile嵌套执行的两种方式\"><a href=\"#Makefile嵌套执行的两种方式\" class=\"headerlink\" title=\"Makefile嵌套执行的两种方式\"></a>Makefile嵌套执行的两种方式</h3><figure class=\"highlight makefile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"section\">subsystem:</span></span><br><span class=\"line\">\tcd subdir &amp;&amp; <span class=\"variable\">$(MAKE)</span></span><br></pre></td></tr></table></figure>\n\n<p>上述脚本使当前的make命令切换目录到指定的目录subdir，该目录下也有一个Makefile文件用于描述subdir下文件的编译规则，然后会再该目录下执行make命令，执行完之后再返回外层的make执行中。这样实现了make的嵌套执行，最外层的Makefile一般称为总控Makefile。</p>\n<p>另一种写法是：</p>\n<figure class=\"highlight makefile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"section\">subsystem:</span></span><br><span class=\"line\">\t<span class=\"variable\">$(MAKE)</span> -C subdir</span><br></pre></td></tr></table></figure>\n\n<p>make的嵌套执行过程中，有一个系统变量“CURDIR”，它表示make的工作目录。当使用-C选项时，命令就会进入指定的目录中，此变量也会被重新赋值。</p>\n<h3 id=\"Make嵌套执行时的参数传递\"><a href=\"#Make嵌套执行时的参数传递\" class=\"headerlink\" title=\"Make嵌套执行时的参数传递\"></a>Make嵌套执行时的参数传递</h3><p>使用make嵌套执行时，如果需要传递变量，可以如下使用：</p>\n<figure class=\"highlight makefile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">export</span> &lt;variable&gt;</span><br></pre></td></tr></table></figure>\n\n<p>如果需要传递所有变量，直接使用export不添加变量名即可。</p>\n<p>有两个变量SHELL和MAKEFLAGS在不管是否使用export关键字的情况下都会传递给被嵌套的Makefile。</p>\n","site":{"data":{}},"excerpt":"<h2 id=\"基本语法与规则\"><a href=\"#基本语法与规则\" class=\"headerlink\" title=\"基本语法与规则\"></a>基本语法与规则</h2><p>Makefile 描述的是文件编译的规则，一条规则主要由两部分组成，依赖关系和命令：</p>\n<figure class=\"highlight makefile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">targets : prerequisites</span><br><span class=\"line\">\tcommand</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>targets: 规则的目标，可以是.o，可以是可执行文件，还可以是一个标签</li>\n<li>prerequisites: 生成目标的依赖文件，可以是多个或者没有</li>\n<li>command: make时需要执行的命令，可以是任意的shell命令，可以有多条命令，每条命令占一行。</li>\n</ul>","more":"<p>Makefile中主要包含的内容：</p>\n<ol>\n<li>显示规则：显式说明如何生成一个目标文件</li>\n<li>隐晦规则：make命令支持自动推导功能</li>\n<li>变量的定义：Makefile中可以定义一系列变量，其用法与shell中的变量类似。</li>\n<li>文件指示：可以在一个makefile中引用另一个makefile，类似c中的include。可以根据某些情况制定makefile中的有效部分，类似c中的条件编译。还可以自定义多行的命令。</li>\n<li>注释：与shell相同，用#号注释。</li>\n</ol>\n<p>make的执行过程：</p>\n<p>在shell中执行make之后，会自动搜索Makefile文件，并且将脚本中的第一条规则</p>\n<p>定义的目标作为最终目标，然后检查目标的依赖，这时有三种情况：</p>\n<ol>\n<li>如果依赖的中间文件不存在，则会根据规则生成中间文件</li>\n<li>如果依赖的中间文件存在，并且没有它所依赖的生成文件新，则会重新生成这个中间文件。</li>\n<li>如果依赖的中间文件存在，并且它所依赖的生成文件也没有更新，则不会重新生成。</li>\n</ol>\n<h2 id=\"Makefile-中的通配符\"><a href=\"#Makefile-中的通配符\" class=\"headerlink\" title=\"Makefile 中的通配符\"></a>Makefile 中的通配符</h2><p>Makefile 支持shell中的通配符，如下：</p>\n<table>\n<thead>\n<tr>\n<th>通配符</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>*</td>\n<td>匹配0个或多个任意字符</td>\n</tr>\n<tr>\n<td>?</td>\n<td>匹配任意一个字符</td>\n</tr>\n<tr>\n<td>[]</td>\n<td>匹配方括号中制定的字符</td>\n</tr>\n</tbody></table>\n<p>通配符在引用变量时的使用，在写依赖规则时，如果直接使用有通配符的变量，会出现错误。如</p>\n<figure class=\"highlight makefile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">obj = *.c</span><br><span class=\"line\">test : <span class=\"variable\">$(obj)</span></span><br><span class=\"line\">\tgcc -o <span class=\"variable\">$@</span> <span class=\"variable\">$^</span></span><br></pre></td></tr></table></figure>\n\n<p>当按如上规则make时，会报错找不到*.c。这是因为变量引用中的通配符并不会被展开。而如果想在引用的变量中使用通配符，则需要借助wildcard函数，这个函数会在引用变量时进行通配符的展开，如：</p>\n<figure class=\"highlight makefile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">obj = <span class=\"variable\">$(<span class=\"built_in\">wildcard</span> *.c)</span></span><br><span class=\"line\">test : <span class=\"variable\">$(obj)</span></span><br><span class=\"line\">\tgcc -o <span class=\"variable\">$@</span> <span class=\"variable\">$^</span></span><br></pre></td></tr></table></figure>\n\n<p>Makefile 中还支持 % 通配符，也是匹配任意个字符，</p>\n<figure class=\"highlight makefile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">test : test1.o test2.o</span><br><span class=\"line\">\tgcc -o <span class=\"variable\">$@</span> <span class=\"variable\">$^</span></span><br><span class=\"line\">%.o : %.c</span><br><span class=\"line\">\tgcc -o <span class=\"variable\">$@</span> <span class=\"variable\">$^</span></span><br></pre></td></tr></table></figure>\n\n<p>%.o会把所有.o文件组合成一个列表，每次从列表中取出一个文件，然后找到文件中和%名称相同的.c文件，然后执行下面的文件，直至列表中的文件取完。这个属于Makefile中静态模规则：规则存在多个目标，规则存在多个目标，并且不同的目标可以根据目标文件的名字自动构造出依赖文件。</p>\n<h2 id=\"Makefile中的变量\"><a href=\"#Makefile中的变量\" class=\"headerlink\" title=\"Makefile中的变量\"></a>Makefile中的变量</h2><h3 id=\"变量的定义\"><a href=\"#变量的定义\" class=\"headerlink\" title=\"变量的定义\"></a>变量的定义</h3><p><code>变量名称 = 值列表</code></p>\n<p>变量名称可以由字母数字和下划线构成，等号左右的空格没有要求，值列表可以是0项，也可以是多项，中间用空格分隔。</p>\n<figure class=\"highlight makefile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">OBJ = a.o b.o c.o</span><br><span class=\"line\">test : <span class=\"variable\">$(OBJ)</span></span><br><span class=\"line\">\tgcc -o test <span class=\"variable\">$(OBJ)</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"变量的基本赋值\"><a href=\"#变量的基本赋值\" class=\"headerlink\" title=\"变量的基本赋值\"></a>变量的基本赋值</h3><ul>\n<li>简单赋值(:&#x3D;)   编程语句中的常规赋值方式，只对当前语句的变量有效</li>\n<li>递归赋值(&#x3D;)    所有目标变量相关的变量都会受影响，赋值语句可能影响多个变量</li>\n<li>条件赋值(?&#x3D;)   如果变量未定义，则使用符号中的值定义变量，</li>\n<li>追加赋值(+&#x3D;)   在变量的值列表后面追加一项新的值</li>\n</ul>\n<figure class=\"highlight makefile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">x = abc</span><br><span class=\"line\">y = <span class=\"variable\">$(x)</span>d</span><br><span class=\"line\">x := efg\t<span class=\"comment\"># 简单赋值 x=efg, y=abcd</span></span><br><span class=\"line\">x = efg\t\t<span class=\"comment\"># 递归赋值 x=efg, y=efgd</span></span><br><span class=\"line\">x ?= efg\t<span class=\"comment\"># 条件赋值 x=abc, y=abcd</span></span><br><span class=\"line\">x += efg\t<span class=\"comment\"># 追加赋值 x=abc efg, y=abcd</span></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"自动化变量\"><a href=\"#自动化变量\" class=\"headerlink\" title=\"自动化变量\"></a>自动化变量</h3><table>\n<thead>\n<tr>\n<th align=\"center\">自动化变量</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">$@</td>\n<td>表示规则的目标文件名。如果目标是一个文档文件（Linux 中，一般成 .a 文件为文档文件，也成为静态的库文件）， 那么它代表这个文档的文件名。在多目标模式规则中，它代表的是触发规则被执行的文件名。</td>\n</tr>\n<tr>\n<td align=\"center\">$%</td>\n<td>当目标文件是一个静态库文件时，代表静态库的一个成员名。</td>\n</tr>\n<tr>\n<td align=\"center\">$&lt;</td>\n<td>规则的第一个依赖的文件名。如果是一个目标文件使用隐含的规则来重建，则它代表由隐含规则加入的第一个依赖文件。</td>\n</tr>\n<tr>\n<td align=\"center\">$?</td>\n<td>所有比目标文件更新的依赖文件列表，空格分隔。如果目标文件时静态库文件，代表的是库文件（.o 文件）。</td>\n</tr>\n<tr>\n<td align=\"center\">$^</td>\n<td>代表的是所有依赖文件列表，使用空格分隔。如果目标是静态库文件，它所代表的只能是所有的库成员（.o 文件）名。 一个文件可重复的出现在目标的依赖中，变量$^ 只记录它的第一次引用的情况。就是说会去掉重复的依赖文件。</td>\n</tr>\n<tr>\n<td align=\"center\">$+</td>\n<td>类似“$^”，但是它保留了依赖文件中重复出现的文件。主要用在程序链接时库的交叉引用场合。</td>\n</tr>\n<tr>\n<td align=\"center\">$*</td>\n<td>在模式规则和静态模式规则中，代表“茎”。“茎”是目标模式中“%”所代表的部分（当文件名中存在目录时， “茎”也包含目录部分）。</td>\n</tr>\n</tbody></table>\n<h2 id=\"Makefile-目标文件搜索路径\"><a href=\"#Makefile-目标文件搜索路径\" class=\"headerlink\" title=\"Makefile 目标文件搜索路径\"></a>Makefile 目标文件搜索路径</h2><p>有两种方式可以制定Makefile脚本搜索目标文件的目录路径：一般搜索<code>VPATH</code> 和选择搜索<code>vpath</code>.</p>\n<p>VPATH和vpath的区别在于，VPATH是一个变量，而且是环境变量，使用时需要指定文件的路径；vpath是关键字，按照指定的模式搜索，搜索时不仅要加上路径，还要加上限值条件。</p>\n<h3 id=\"VPATH\"><a href=\"#VPATH\" class=\"headerlink\" title=\"VPATH\"></a>VPATH</h3><p>在Makefile中按如下形式使用VPATH指定搜索路径：</p>\n<figure class=\"highlight makefile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">VPATH := src</span><br></pre></td></tr></table></figure>\n\n<p>当要指定多个路径时，不同的路径之间用空格或者冒号分隔。</p>\n<figure class=\"highlight makefile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">VPAHT := path1:path2</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"vpath\"><a href=\"#vpath\" class=\"headerlink\" title=\"vpath\"></a>vpath</h3><p>vpath按照给定模式在指定目录中搜索，使用方法如下：</p>\n<figure class=\"highlight makefile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1. <span class=\"keyword\">vpath</span> PATTERN DIRECTORIES</span><br><span class=\"line\">2. <span class=\"keyword\">vpath</span> PATTERN</span><br><span class=\"line\">3. <span class=\"keyword\">vpath</span></span><br></pre></td></tr></table></figure>\n\n<p>用法二的意思是清除符合模式 的搜索目录，用法3 单独使用vpath是清楚所有已设置的文件搜索路径。</p>\n<h3 id=\"应用\"><a href=\"#应用\" class=\"headerlink\" title=\"应用\"></a>应用</h3><p>假设现在有一个工程，包含两个目录，src目录下包含main.c, module1.c, module2.c源文件，inc目录下包含module1.h, module2.h头文件。通过如下方式先声明文件搜索路径。</p>\n<figure class=\"highlight makefile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">vpath</span> %.c \tsrc</span><br><span class=\"line\"><span class=\"keyword\">vpath</span> %.h\tinc\t\t<span class=\"comment\">## 或者使用 VPATH = src inc</span></span><br><span class=\"line\">main : main.o module1.o module2.o</span><br><span class=\"line\">\tgcc -o <span class=\"variable\">$@</span> <span class=\"variable\">$&lt;</span></span><br><span class=\"line\">main.o : main.c</span><br><span class=\"line\">\tgcc -o <span class=\"variable\">$@</span> <span class=\"variable\">$^</span></span><br><span class=\"line\">module1.o : module1.c module1.h</span><br><span class=\"line\">\tgcc -o <span class=\"variable\">$@</span> <span class=\"variable\">$&lt;</span></span><br><span class=\"line\">module2.o : module2.c module2.h</span><br><span class=\"line\">\tgcc -o <span class=\"variable\">$@</span> <span class=\"variable\">$&lt;</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"Makefile-隐含规则\"><a href=\"#Makefile-隐含规则\" class=\"headerlink\" title=\"Makefile 隐含规则\"></a>Makefile 隐含规则</h2><h2 id=\"Makefile-条件判断\"><a href=\"#Makefile-条件判断\" class=\"headerlink\" title=\"Makefile 条件判断\"></a>Makefile 条件判断</h2><p>在实际工程中，经常会遇到要根据某个条件执行不同的编译操作的情况。这是就需要在Makefile中能够实现分条件执行语句的功能。Makefile中提供以下条件判断关键字：</p>\n<table>\n<thead>\n<tr>\n<th>关键字</th>\n<th>说明</th>\n<th></th>\n</tr>\n</thead>\n<tbody><tr>\n<td>ifeq</td>\n<td>判断参数是否相等</td>\n<td></td>\n</tr>\n<tr>\n<td>ifneq</td>\n<td>判断参数是否不等</td>\n<td></td>\n</tr>\n<tr>\n<td>ifdef</td>\n<td>判断是否有值</td>\n<td></td>\n</tr>\n<tr>\n<td>ifndef</td>\n<td>判断是否没有值</td>\n<td></td>\n</tr>\n</tbody></table>\n<h3 id=\"ifeq-和-ifneq\"><a href=\"#ifeq-和-ifneq\" class=\"headerlink\" title=\"ifeq 和 ifneq\"></a>ifeq 和 ifneq</h3><p>使用语法</p>\n<figure class=\"highlight makefile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">ifeq</span> (ARG1, arg2)</span><br><span class=\"line\"><span class=\"comment\"># ifeq &quot;ARG1&quot; &quot;ARG2&quot;</span></span><br><span class=\"line\"><span class=\"comment\"># ifeq &#x27;ARG1&#x27; &#x27;ARG2&#x27;</span></span><br><span class=\"line\">\txxx</span><br><span class=\"line\"><span class=\"keyword\">else</span></span><br><span class=\"line\">\txxx</span><br><span class=\"line\"><span class=\"keyword\">endif</span></span><br></pre></td></tr></table></figure>\n\n<p>举例</p>\n<figure class=\"highlight makefile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">gcc_libs = -lgnu</span><br><span class=\"line\">default_libs = </span><br><span class=\"line\"><span class=\"keyword\">ifeq</span> (<span class=\"variable\">$(CC)</span>, gcc)</span><br><span class=\"line\">\tlibs = <span class=\"variable\">$(gcc_libs)</span></span><br><span class=\"line\"><span class=\"keyword\">else</span></span><br><span class=\"line\">\tlibs = <span class=\"variable\">$(default_libs)</span></span><br><span class=\"line\"><span class=\"keyword\">endif</span></span><br><span class=\"line\">foo : <span class=\"variable\">$(objects)</span></span><br><span class=\"line\">\t<span class=\"variable\">$(CC)</span> -o foo <span class=\"variable\">$(objects)</span> <span class=\"variable\">$(libs)</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"ifdef-和-ifndef\"><a href=\"#ifdef-和-ifndef\" class=\"headerlink\" title=\"ifdef 和 ifndef\"></a>ifdef 和 ifndef</h3><p>使用语法：</p>\n<figure class=\"highlight makefile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">ifdef</span> VARIABLE_NAME</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"Makefile-伪目标\"><a href=\"#Makefile-伪目标\" class=\"headerlink\" title=\"Makefile 伪目标\"></a>Makefile 伪目标</h2><p>伪目标的含义是它并不会创建目标文件，但是会去执行这个目标下面的命令。使用伪目标有两点原因：</p>\n<ol>\n<li><p>避免Makefile中只用来执行命令的目标与时间的文件出现名字冲突</p>\n</li>\n<li><p>提高执行make时的效率</p>\n</li>\n<li><p>文件清理操作clean作为伪目标的实现：</p>\n</li>\n</ol>\n<figure class=\"highlight makefile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.PHONY : clean</span><br><span class=\"line\">clean :</span><br><span class=\"line\">\trm -rf *.o <span class=\"variable\">$(PROGRAM)</span></span><br></pre></td></tr></table></figure>\n\n<ol start=\"2\">\n<li>make 命令对于多个目录的并行和递归操作：</li>\n</ol>\n<figure class=\"highlight makefile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">SUBDIRS = foo bar baz</span><br><span class=\"line\">.PHONY : subdirs <span class=\"variable\">$(SUBDIRS)</span></span><br><span class=\"line\">subdirs : <span class=\"variable\">$(SUBDIRS)</span></span><br><span class=\"line\"><span class=\"variable\">$(SUBDIRS)</span> : </span><br><span class=\"line\">\t<span class=\"variable\">$(MAKE)</span> -C <span class=\"variable\">$@</span></span><br><span class=\"line\"><span class=\"section\">foo: baz</span></span><br></pre></td></tr></table></figure>\n\n<p>​\t\t\t上述脚本实现了递归的调用三个子目录下的make命令。</p>\n<ol start=\"3\">\n<li><p>伪目标实现多目标文件的生成</p>\n<p>如果想要在一个Makefile里控制生成多个可执行文件，也可以借助伪目标实现：</p>\n<figure class=\"highlight makefile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.PHONY all</span><br><span class=\"line\">all : test1 test2 test3</span><br><span class=\"line\">test1 : test1.o</span><br><span class=\"line\">\tgcc -o <span class=\"variable\">$@</span> <span class=\"variable\">$^</span></span><br><span class=\"line\">test2 : test2.o</span><br><span class=\"line\">\tgcc -o <span class=\"variable\">$@</span> <span class=\"variable\">$^</span></span><br><span class=\"line\">test3 : test3.o</span><br><span class=\"line\">\tgcc -o <span class=\"variable\">$@</span> <span class=\"variable\">$^</span></span><br></pre></td></tr></table></figure>\n\n<p>上述脚本通过声明一个all伪目标，实现同时生成test1, test2, test3三个目标可执行文件。</p>\n</li>\n</ol>\n<h2 id=\"Makefile中的字符串处理函数\"><a href=\"#Makefile中的字符串处理函数\" class=\"headerlink\" title=\"Makefile中的字符串处理函数\"></a>Makefile中的字符串处理函数</h2><p>Makefile中调用函数的语法：</p>\n<p><code>$(&lt;function&gt; &lt;arguments&gt;)</code> 或者 <code>$&#123;&lt;function&gt; &lt;arguments&gt;&#125;</code> </p>\n<p>其中function是函数名，arguments是参数列表。函数名和参数列表之间用空格分开，参数列表中的多个参数用逗号分隔。</p>\n<h3 id=\"模式字符串替换函数\"><a href=\"#模式字符串替换函数\" class=\"headerlink\" title=\"模式字符串替换函数\"></a>模式字符串替换函数</h3><p>使用格式：</p>\n<figure class=\"highlight makefile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"variable\">$(<span class=\"built_in\">patsubst</span> &lt;pattern&gt;, &lt;replacement&gt;, &lt;text&gt;)</span></span><br></pre></td></tr></table></figure>\n\n<p>说明：查找text中符合模式pattern的部分，如果找到匹配的，则用replacement替换。返回替换后的新字符串。</p>\n<p>常见用法示例：</p>\n<figure class=\"highlight makefile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">C_SOURCE = <span class=\"variable\">$(<span class=\"built_in\">shell</span> find . -name *.c)</span></span><br><span class=\"line\">C_OBJECTS=<span class=\"variable\">$(<span class=\"built_in\">patsubst</span> %.c, %.o, <span class=\"variable\">$(C_SOURCE)</span>)</span></span><br><span class=\"line\">main : <span class=\"variable\">$(C_OBJECTS)</span></span><br><span class=\"line\">\tgcc -o <span class=\"variable\">$@</span> <span class=\"variable\">$^</span></span><br><span class=\"line\"><span class=\"variable\">$(C_OBJECTS)</span> : <span class=\"variable\">$(C_SOURCE)</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"字符串替换函数\"><a href=\"#字符串替换函数\" class=\"headerlink\" title=\"字符串替换函数\"></a>字符串替换函数</h3><figure class=\"highlight makefile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"variable\">$(<span class=\"built_in\">subst</span> &lt;from&gt;, &lt;to&gt;, &lt;text&gt;)</span></span><br></pre></td></tr></table></figure>\n\n<p>将text字符串中的from替换成to，返回替换后的新字符串</p>\n<p>用法示例：</p>\n<figure class=\"highlight makefile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">OBJ = <span class=\"variable\">$(<span class=\"built_in\">subst</span> Beijing, Shanghai, I love Beijing)</span></span><br><span class=\"line\"><span class=\"section\">all:</span></span><br><span class=\"line\">\t@echo <span class=\"variable\">$(OBJ)</span>\t<span class=\"comment\"># 显示 I love Shanghai</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"去空格函数\"><a href=\"#去空格函数\" class=\"headerlink\" title=\"去空格函数\"></a>去空格函数</h3><figure class=\"highlight makefile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"variable\">$(<span class=\"built_in\">strip</span> &lt;string&gt;)</span></span><br></pre></td></tr></table></figure>\n\n<p>去掉string开头和结尾的空格，并且将中间连续多个空格合并为一个空格。返回去空格后的字符串。</p>\n<h3 id=\"字符串查找函数\"><a href=\"#字符串查找函数\" class=\"headerlink\" title=\"字符串查找函数\"></a>字符串查找函数</h3><figure class=\"highlight makefile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"variable\">$(<span class=\"built_in\">findstring</span> &lt;find&gt;, &lt;in&gt;)</span></span><br></pre></td></tr></table></figure>\n\n<p>在in中查找find，如果查找的目标字符串存在，返回目标字符串，如果不存在返回空。</p>\n<p>用法示例</p>\n<figure class=\"highlight makefile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">OBJ = <span class=\"variable\">$(<span class=\"built_in\">findstring</span> you, I hate you)</span></span><br><span class=\"line\"><span class=\"section\">all:</span></span><br><span class=\"line\">\t@echo <span class=\"variable\">$(OBJ)</span>\t<span class=\"comment\"># 显示 you</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"模式过滤函数\"><a href=\"#模式过滤函数\" class=\"headerlink\" title=\"模式过滤函数\"></a>模式过滤函数</h3><figure class=\"highlight makefile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"variable\">$(<span class=\"built_in\">filter</span> &lt;pattern&gt;, &lt;text&gt;)</span></span><br></pre></td></tr></table></figure>\n\n<p>过滤出text中符合模式pattern的字符串，可以有多个pattern，返回所有符合pattern的字符串。</p>\n<p>用法示例：</p>\n<figure class=\"highlight makefile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">OBJ = <span class=\"variable\">$(<span class=\"built_in\">filter</span> %.c %.o, foo1.c foo2.o foo3.s)</span></span><br><span class=\"line\"><span class=\"section\">all:</span></span><br><span class=\"line\">\t@echo <span class=\"variable\">$(OBJ)</span>\t<span class=\"comment\">#显示foo1.c foo2.o</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"反向过滤函数\"><a href=\"#反向过滤函数\" class=\"headerlink\" title=\"反向过滤函数\"></a>反向过滤函数</h3><figure class=\"highlight makefile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"variable\">$(<span class=\"built_in\">filter</span>-out &lt;pattern&gt;, &lt;text&gt;)</span></span><br></pre></td></tr></table></figure>\n\n<p>与filter函数相反，滤除所有符合pattern模式的字符串，返回所有不符合pattern的字符串。</p>\n<figure class=\"highlight makefile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">OBJ = <span class=\"variable\">$(<span class=\"built_in\">filter</span>-out %.c %.o, foo1.c foo2.o foo3.s)</span></span><br><span class=\"line\"><span class=\"section\">all:</span></span><br><span class=\"line\">\t@echo <span class=\"variable\">$(OBJ)</span>\t<span class=\"comment\">#显示foo3.s</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"排序函数\"><a href=\"#排序函数\" class=\"headerlink\" title=\"排序函数\"></a>排序函数</h3><figure class=\"highlight makefile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"variable\">$(<span class=\"built_in\">sort</span> &lt;list&gt;)</span></span><br></pre></td></tr></table></figure>\n\n<p>将list中的单词按照单词升序排序，返回排序后的字符串</p>\n<p>示例：</p>\n<figure class=\"highlight makefile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">OBJ = <span class=\"variable\">$(<span class=\"built_in\">sort</span> orange apple pear apple)</span></span><br><span class=\"line\"><span class=\"section\">all: </span></span><br><span class=\"line\">\t@echo <span class=\"variable\">$(OBJ)</span> <span class=\"comment\"># 显示 apple orange pear</span></span><br></pre></td></tr></table></figure>\n\n<p><strong>notice</strong> : sort会去掉重复的字符串</p>\n<h3 id=\"去单词函数\"><a href=\"#去单词函数\" class=\"headerlink\" title=\"去单词函数\"></a>去单词函数</h3><figure class=\"highlight makefile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"variable\">$(<span class=\"built_in\">word</span> &lt;n&gt;, &lt;text&gt;)</span></span><br></pre></td></tr></table></figure>\n\n<p>取出字符串text中的第n个单词，返回取出的第n个单词。</p>\n<p>示例：</p>\n<figure class=\"highlight makefile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">OBJ = <span class=\"variable\">$(<span class=\"built_in\">word</span> 2, foo1.c foo2.c foo3.c)</span></span><br><span class=\"line\"><span class=\"section\">all:</span></span><br><span class=\"line\">\t@echo <span class=\"variable\">$(OBJ)</span>\t<span class=\"comment\"># 显示 foo2.c</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"Makefile-中的文件名操作函数\"><a href=\"#Makefile-中的文件名操作函数\" class=\"headerlink\" title=\"Makefile 中的文件名操作函数\"></a>Makefile 中的文件名操作函数</h2><h3 id=\"取目录函数\"><a href=\"#取目录函数\" class=\"headerlink\" title=\"取目录函数\"></a>取目录函数</h3><figure class=\"highlight makefile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"variable\">$(<span class=\"built_in\">dir</span> &lt;names&gt;)</span></span><br></pre></td></tr></table></figure>\n\n<p>从文件名序列names中取出所有文件的目录部分，如果文件名不包含任何路径，则取出的是“.&#x2F;”。返回文件序列的目录部分。</p>\n<h3 id=\"取文件函数\"><a href=\"#取文件函数\" class=\"headerlink\" title=\"取文件函数\"></a>取文件函数</h3><figure class=\"highlight makefile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"variable\">$(<span class=\"built_in\">notdir</span> &lt;names&gt;)</span></span><br></pre></td></tr></table></figure>\n\n<p>从文件名序列names中取出所欲的非目录部分，返回取出的非目录部分。</p>\n<h3 id=\"取后缀函数\"><a href=\"#取后缀函数\" class=\"headerlink\" title=\"取后缀函数\"></a>取后缀函数</h3><figure class=\"highlight makefile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"variable\">$(<span class=\"built_in\">suffix</span> &lt;names&gt;)</span></span><br></pre></td></tr></table></figure>\n\n<p>从文件名序列names中取出各个文件的后缀名，如果文件名没有后缀，则取出结果为空，返回取出的后缀名序列。</p>\n<h3 id=\"取前缀函数\"><a href=\"#取前缀函数\" class=\"headerlink\" title=\"取前缀函数\"></a>取前缀函数</h3><figure class=\"highlight makefile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"variable\">$(<span class=\"built_in\">basename</span> &lt;names&gt;)</span></span><br></pre></td></tr></table></figure>\n\n<p>从文件名序列names中取出各个文件名的前缀部分（包含路径），返回取出的前缀名序列。</p>\n<h3 id=\"添加后缀名函数\"><a href=\"#添加后缀名函数\" class=\"headerlink\" title=\"添加后缀名函数\"></a>添加后缀名函数</h3><figure class=\"highlight makefile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"variable\">$(<span class=\"built_in\">addsuffix</span> &lt;<span class=\"built_in\">suffix</span>&gt;, &lt;names&gt;)</span></span><br></pre></td></tr></table></figure>\n\n<p>将后缀suffix添加到文件名列表names中的每个单词后面。返回添加后缀后的文件名序列。</p>\n<h3 id=\"添加前缀名函数\"><a href=\"#添加前缀名函数\" class=\"headerlink\" title=\"添加前缀名函数\"></a>添加前缀名函数</h3><figure class=\"highlight makefile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"variable\">$(<span class=\"built_in\">addprefix</span> &lt;prefix&gt;, &lt;names&gt;)</span></span><br></pre></td></tr></table></figure>\n\n<p>将前缀prefix添加到文件名序列names中的每个单词前面，返回添加前缀之后的文件名序列。</p>\n<h3 id=\"链接函数\"><a href=\"#链接函数\" class=\"headerlink\" title=\"链接函数\"></a>链接函数</h3><figure class=\"highlight makefile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"variable\">$(<span class=\"built_in\">join</span> &lt;list1&gt;, &lt;list2&gt;)</span></span><br></pre></td></tr></table></figure>\n\n<p>将list2中的单词一一对应的拼接到list1中的单词后，如果list1的单词比list2多，那么list1后面多出来的单词保持不变。如果list1的单词比list2少，那么list2后面多出来的单词保持不变。返回拼接之后的单词序列</p>\n<h3 id=\"获取匹配模式文件名函数\"><a href=\"#获取匹配模式文件名函数\" class=\"headerlink\" title=\"获取匹配模式文件名函数\"></a>获取匹配模式文件名函数</h3><figure class=\"highlight makefile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"variable\">$(<span class=\"built_in\">wildcard</span> PATTERN)</span></span><br></pre></td></tr></table></figure>\n\n<p>列出当前目录下所有符合模式的PATTERN格式的文件名，返回由空格分隔的当前目录下所有符合PATTERN模式的文件名。</p>\n<h3 id=\"Exam\"><a href=\"#Exam\" class=\"headerlink\" title=\"Exam\"></a>Exam</h3><figure class=\"highlight makefile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">OBJ = <span class=\"variable\">$(<span class=\"built_in\">dir</span> src/main.c src/module1.c inc/module1.h bsp.h)</span></span><br><span class=\"line\"><span class=\"section\">all:</span></span><br><span class=\"line\">\t@echo <span class=\"variable\">$(OBJ)</span>\t<span class=\"comment\">#显示 src/ src/ inc/ ./</span></span><br><span class=\"line\">\t</span><br><span class=\"line\">OBJ = <span class=\"variable\">$(<span class=\"built_in\">notdir</span> src/main.c src/module1.c inc/module1.h bsp.h)</span></span><br><span class=\"line\"><span class=\"section\">all:</span></span><br><span class=\"line\">\t@echo <span class=\"variable\">$(OBJ)</span>\t<span class=\"comment\">#显示main.c module1.c module1.h bsp.h</span></span><br><span class=\"line\">\t</span><br><span class=\"line\">OBJ = <span class=\"variable\">$(<span class=\"built_in\">suffix</span> src/main.c src/module1.c inc/module1.h bsp.h)</span></span><br><span class=\"line\"><span class=\"section\">all:</span></span><br><span class=\"line\">\t@echo <span class=\"variable\">$(OBJ)</span>\t<span class=\"comment\">#显示.c .c .h .h</span></span><br><span class=\"line\">\t</span><br><span class=\"line\">OBJ = <span class=\"variable\">$(<span class=\"built_in\">basename</span> src/main.c src/module1.c inc/module1.h bsp.h)</span></span><br><span class=\"line\"><span class=\"section\">all:</span></span><br><span class=\"line\">\t@echo <span class=\"variable\">$(OBJ)</span>\t<span class=\"comment\">#显示 src/main src/module1 inc/module1 bsp</span></span><br><span class=\"line\"></span><br><span class=\"line\">OBJ = <span class=\"variable\">$(<span class=\"built_in\">addsuffix</span> .c, src/main src/module1)</span></span><br><span class=\"line\"><span class=\"section\">all:</span></span><br><span class=\"line\">\t@echo <span class=\"variable\">$(OBJ)</span>\t<span class=\"comment\">#显示 src/main.c src/module1.c</span></span><br><span class=\"line\">\t</span><br><span class=\"line\">OBJ = <span class=\"variable\">$(<span class=\"built_in\">addprefix</span> src/, main.c module1.c)</span></span><br><span class=\"line\"><span class=\"section\">all:</span></span><br><span class=\"line\">\t@echo <span class=\"variable\">$(OBJ)</span>\t<span class=\"comment\">#显示 src/main.c src/module1.c</span></span><br><span class=\"line\">\t</span><br><span class=\"line\">OBJ = <span class=\"variable\">$(<span class=\"built_in\">join</span> main module1 module2, .c .h)</span></span><br><span class=\"line\"><span class=\"section\">all:</span></span><br><span class=\"line\">\t@echo <span class=\"variable\">$(OBJ)</span>\t<span class=\"comment\">#显示 main.c module1.h module2</span></span><br><span class=\"line\">\t</span><br><span class=\"line\">OBJ = <span class=\"variable\">$(<span class=\"built_in\">wildcard</span> *.c *.h)</span></span><br><span class=\"line\">main : <span class=\"variable\">$(OBJ)</span></span><br><span class=\"line\">\tgcc -o <span class=\"variable\">$@</span> <span class=\"variable\">$^</span></span><br><span class=\"line\">\t</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"Makefile其他常用函数\"><a href=\"#Makefile其他常用函数\" class=\"headerlink\" title=\"Makefile其他常用函数\"></a>Makefile其他常用函数</h2><h3 id=\"遍历函数\"><a href=\"#遍历函数\" class=\"headerlink\" title=\"遍历函数\"></a>遍历函数</h3><figure class=\"highlight makefile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"variable\">$(<span class=\"built_in\">foreach</span> &lt;var&gt;, &lt;list&gt;, &lt;text&gt;)</span></span><br></pre></td></tr></table></figure>\n\n<p>把参数list中的单词逐一取出放到参数var所指定的变量中，然后再执行text所包含的表达式，最终遍历完成后返回由空格分隔的遍历执行结果。</p>\n<p><strong>Notice</strong> foreach函数中的var是一个临时变量，作用域只在该函数中，执行结束后就不再起作用。</p>\n<figure class=\"highlight makefile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">name = main module1 module2</span><br><span class=\"line\">files = <span class=\"variable\">$(<span class=\"built_in\">foreach</span> n, <span class=\"variable\">$(name)</span>, <span class=\"variable\">$(n)</span>.o)</span></span><br><span class=\"line\"><span class=\"section\">all:</span></span><br><span class=\"line\">\t@echo <span class=\"variable\">$(files)</span>  <span class=\"comment\">#显示 main.o module1.o module2.o</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"条件执行函数\"><a href=\"#条件执行函数\" class=\"headerlink\" title=\"条件执行函数\"></a>条件执行函数</h3><figure class=\"highlight makefile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"variable\">$(<span class=\"built_in\">if</span> &lt;condition&gt;, &lt;then-part&gt;)</span></span><br><span class=\"line\"><span class=\"variable\">$(<span class=\"built_in\">if</span> &lt;condition&gt;, &lt;then-part&gt;, &lt;else-part&gt;)</span></span><br></pre></td></tr></table></figure>\n\n<p>当condition为真，则执行then-part部分，否则执行else-part部分，返回执行结果，如果condition为假且else-part为空，则返回空字符串。condition为真的条件为condition为非空字符串。</p>\n<figure class=\"highlight makefile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">OBJ = foo.c</span><br><span class=\"line\">OBJ = <span class=\"variable\">$(<span class=\"built_in\">if</span> <span class=\"variable\">$(OBJ)</span>, <span class=\"variable\">$(OBJ)</span>, main.c)</span></span><br><span class=\"line\"><span class=\"section\">all:</span></span><br><span class=\"line\">\t@echo <span class=\"variable\">$(OBJ)</span>\t\t<span class=\"comment\">#显示 foo.c</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"参数替换函数\"><a href=\"#参数替换函数\" class=\"headerlink\" title=\"参数替换函数\"></a>参数替换函数</h3><figure class=\"highlight makefile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"variable\">$(<span class=\"built_in\">call</span> &lt;expression&gt;, &lt;parm1&gt;, &lt;parm2&gt;, &lt;parm3&gt;, ...)</span></span><br></pre></td></tr></table></figure>\n\n<p>expression是一个包含参数的表达式，但call被执行时，expression中的参数变量$(1)，$(2)，$(3)等会被后面的参数parm1， parm2, parm3依次取代。最终返回替换完之后expression的值。</p>\n<figure class=\"highlight makefile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">files = $(2).c $(1).c</span><br><span class=\"line\">obj = <span class=\"variable\">$(<span class=\"built_in\">call</span> files, main, module)</span></span><br><span class=\"line\"><span class=\"section\">all:</span></span><br><span class=\"line\">\t@echo <span class=\"variable\">$(obj)</span>\t<span class=\"comment\">#显示 module.c main.c</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"变量属性函数\"><a href=\"#变量属性函数\" class=\"headerlink\" title=\"变量属性函数\"></a>变量属性函数</h3><figure class=\"highlight makefile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"variable\">$(<span class=\"built_in\">origin</span> &lt;variable&gt;)</span></span><br></pre></td></tr></table></figure>\n\n<p>origin 函数不会操作变量的值，他只会返回这个变量的来源。这里variable是变量的名字，不应该是引用，最好不要在variable中使用$字符。下面是origin函数的返回值：</p>\n<table>\n<thead>\n<tr>\n<th>返回值</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>undefined</td>\n<td>variable从没有定义过</td>\n</tr>\n<tr>\n<td>default</td>\n<td>variable是默认定义的变量，如CC</td>\n</tr>\n<tr>\n<td>environment</td>\n<td>variable是一个环境变量，并且makefile执行时没有-e选项</td>\n</tr>\n<tr>\n<td>file</td>\n<td>variable是在Makefile中定义的变量</td>\n</tr>\n<tr>\n<td>command line</td>\n<td>variable这个变量是被命令执行的</td>\n</tr>\n<tr>\n<td>override</td>\n<td>variable是被override指示符重新定义的</td>\n</tr>\n<tr>\n<td>automatic</td>\n<td>variable是一个命令行中的自动化变量</td>\n</tr>\n</tbody></table>\n<h2 id=\"Makefile的文件包含与嵌套执行\"><a href=\"#Makefile的文件包含与嵌套执行\" class=\"headerlink\" title=\"Makefile的文件包含与嵌套执行\"></a>Makefile的文件包含与嵌套执行</h2><p> Makefile中可以通过include关键字来包含其他文件，当make命令遇到include关键字时，会暂停读取当前的Makefile，而是取读取include包含的文件，读取结束后再继续运行Makefile文件。具体用法如下：</p>\n<figure class=\"highlight makefile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">include</span> &lt;filenames&gt;</span><br><span class=\"line\"><span class=\"keyword\">-include</span> &lt;filenames&gt;</span><br></pre></td></tr></table></figure>\n\n<p>上述两种使用方式的区别在于：</p>\n<ul>\n<li>使用 <code>include &lt;filenames&gt;</code> ，make 在处理程序的时候，文件列表中的任意一个文件不存在的时候或者是没有规则去创建这个文件的时候，make 程序将会提示错误并保存退出。</li>\n<li>使用 <code>-include &lt;filenames&gt;</code>，当包含的文件不存在或者是没有规则去创建它的时候，make 将会继续执行程序，只有真正由于不能完成终极目标重建的时候我们的程序才会提示错误保存退出。</li>\n</ul>\n<p><strong>Notice</strong> :使用include包含进来的 Makefile 文件中，如果存在函数或者是变量的引用，它们会在包含的 Makefile 中展开。</p>\n<h3 id=\"Makefile嵌套执行的两种方式\"><a href=\"#Makefile嵌套执行的两种方式\" class=\"headerlink\" title=\"Makefile嵌套执行的两种方式\"></a>Makefile嵌套执行的两种方式</h3><figure class=\"highlight makefile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"section\">subsystem:</span></span><br><span class=\"line\">\tcd subdir &amp;&amp; <span class=\"variable\">$(MAKE)</span></span><br></pre></td></tr></table></figure>\n\n<p>上述脚本使当前的make命令切换目录到指定的目录subdir，该目录下也有一个Makefile文件用于描述subdir下文件的编译规则，然后会再该目录下执行make命令，执行完之后再返回外层的make执行中。这样实现了make的嵌套执行，最外层的Makefile一般称为总控Makefile。</p>\n<p>另一种写法是：</p>\n<figure class=\"highlight makefile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"section\">subsystem:</span></span><br><span class=\"line\">\t<span class=\"variable\">$(MAKE)</span> -C subdir</span><br></pre></td></tr></table></figure>\n\n<p>make的嵌套执行过程中，有一个系统变量“CURDIR”，它表示make的工作目录。当使用-C选项时，命令就会进入指定的目录中，此变量也会被重新赋值。</p>\n<h3 id=\"Make嵌套执行时的参数传递\"><a href=\"#Make嵌套执行时的参数传递\" class=\"headerlink\" title=\"Make嵌套执行时的参数传递\"></a>Make嵌套执行时的参数传递</h3><p>使用make嵌套执行时，如果需要传递变量，可以如下使用：</p>\n<figure class=\"highlight makefile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">export</span> &lt;variable&gt;</span><br></pre></td></tr></table></figure>\n\n<p>如果需要传递所有变量，直接使用export不添加变量名即可。</p>\n<p>有两个变量SHELL和MAKEFLAGS在不管是否使用export关键字的情况下都会传递给被嵌套的Makefile。</p>"}],"PostAsset":[],"PostCategory":[{"post_id":"cl8oshjpp000116u78r0g9nvq","category_id":"cl8oshjpt000416u7cq1l5ujr","_id":"cl8oshjpw000816u71j7oav96"},{"post_id":"cl8oshjpx000b16u78mlqhz2p","category_id":"cl8oshjpt000416u7cq1l5ujr","_id":"cl8oshjpy000d16u7fl5desbo"}],"PostTag":[{"post_id":"cl8oshjpp000116u78r0g9nvq","tag_id":"cl8oshjpu000516u7283tb48y","_id":"cl8oshjpx000916u70y4lf34m"},{"post_id":"cl8oshjpp000116u78r0g9nvq","tag_id":"cl8oshjpw000716u7ak054b6n","_id":"cl8oshjpx000a16u782k248jc"},{"post_id":"cl8oshjpx000b16u78mlqhz2p","tag_id":"cl8oshjpy000c16u7d1ojbc64","_id":"cl8oshjpy000f16u79c58dcdc"},{"post_id":"cl8oshjpx000b16u78mlqhz2p","tag_id":"cl8oshjpy000e16u7066g2el8","_id":"cl8oshjpy000g16u72m7g7kzb"}],"Tag":[{"name":"c++","_id":"cl8oshjpu000516u7283tb48y"},{"name":"programming basic","_id":"cl8oshjpw000716u7ak054b6n"},{"name":"embedded","_id":"cl8oshjpy000c16u7d1ojbc64"},{"name":"Linux","_id":"cl8oshjpy000e16u7066g2el8"}]}}